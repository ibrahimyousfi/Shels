{
  "id": "session_1768741079616_vuxfh3ci7",
  "name": "Analysis: Shels",
  "timestamp": 1768741079616,
  "repoUrl": "https://github.com/ibrahimyousfi/Shels",
  "results": {
    "analysis": {
      "totalFiles": 60,
      "totalLines": 6256,
      "issues": [
        {
          "type": "security",
          "severity": "high",
          "file": "app/api/sessions/[id]/route.ts",
          "line": 15,
          "description": "Path Traversal vulnerability. The 'id' parameter from the URL is used directly in 'path.join' without validation, allowing an attacker to read or delete arbitrary JSON files on the server using '../' sequences.",
          "suggestion": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'."
        },
        {
          "type": "bug",
          "severity": "high",
          "file": "app/api/marathon/route.ts",
          "line": 4,
          "description": "State persistence issue. The 'activeAgents' Map is stored in-memory. In serverless environments like Vercel, this state will be lost when the lambda cold-starts or scales, causing 'Agent not found' errors for running tasks.",
          "suggestion": "Use an external database or Redis to store active agent configurations and status to ensure persistence across serverless invocations."
        },
        {
          "type": "performance",
          "severity": "medium",
          "file": "lib/services/repoReader.ts",
          "line": 105,
          "description": "Sequential recursive API calls. 'readDirectoryRecursive' awaits each subdirectory and file download sequentially. For large repositories, this leads to extremely long execution times and potential API timeouts.",
          "suggestion": "Implement concurrency limits using 'Promise.all' with a semaphore or a library like 'p-limit' to fetch multiple files/directories in parallel."
        },
        {
          "type": "security",
          "severity": "medium",
          "file": "lib/services/repoReader.ts",
          "line": 84,
          "description": "GitHub API Rate Limiting. The fetch calls to GitHub are unauthenticated. GitHub limits unauthenticated requests to 60 per hour per IP. Multiple users will quickly exhaust this quota, causing the app to fail.",
          "suggestion": "Implement GitHub OAuth or use a Personal Access Token (PAT) passed via environment variables in the request headers."
        },
        {
          "type": "error_handling",
          "severity": "medium",
          "file": "lib/services/autoFix.ts",
          "line": 34,
          "description": "Fragile JSON parsing. The service uses a RegExp to extract JSON from the AI response. If the AI response contains multiple JSON-like blocks or markdown code fences, 'JSON.parse' will likely fail.",
          "suggestion": "Use a more robust parsing utility that handles markdown code blocks (e.g., removing ```json tags) and provides fallbacks if the root element is not found."
        },
        {
          "type": "quality",
          "severity": "low",
          "file": "app/api/sessions/route.ts",
          "line": 95,
          "description": "Inefficient session cleanup. The code reads and parses every single session file to find timestamps for cleanup. This O(n) operation runs on every POST request and will become slow as the number of sessions grows.",
          "suggestion": "Store session metadata in a single index file or database to avoid reading and parsing all files just for a cleanup check."
        },
        {
          "type": "bug",
          "severity": "medium",
          "file": "lib/services/codeAnalyzer.ts",
          "line": 102,
          "description": "Inconsistent Issue Mapping. The 'CodeIssue' interface defines 'type' as a union of 5 specific strings, but 'analyzeCodebase' relies on AI to return valid JSON. There is no runtime validation to ensure the AI actually returned one of those 5 types.",
          "suggestion": "Implement a schema validation layer (like Zod) to validate the AI response and map unexpected types to a 'quality' default."
        }
      ],
      "structure": {
        "mainFiles": [
          "app/api/analyze/route.ts",
          "lib/services/codeAnalyzer.ts",
          "app/page.tsx",
          "hooks/useCodeTesting.ts"
        ],
        "dependencies": [
          "@google/genai",
          "next",
          "react",
          "tailwind-css",
          "geist-fonts"
        ],
        "architecture": "Next.js App Router architecture with a Service-oriented backend. Features a clean separation between API routes (controllers), services (business logic/AI integration), and React components (view)."
      },
      "summary": "The codebase is a sophisticated AI-powered tool leveraging the Google Gemini API. It shows a strong modular design, particularly in the separation of AI services (Metrics, Risk, Business Impact). However, it suffers from typical 'prototype-to-production' gaps: specifically, lack of input sanitization in filesystem operations (Path Traversal), reliance on in-memory state in serverless-targeted code (Marathon Agent), and unauthenticated external API usage (GitHub). The UI is highly responsive but the backend services need a validation layer for AI-generated data to ensure runtime stability.",
      "analysisScope": {
        "analyzedFileTypes": [
          "JavaScript",
          "TypeScript",
          "Python",
          "Java",
          "C++",
          "C#",
          "Go",
          "Rust",
          "PHP",
          "Ruby",
          "Swift",
          "Kotlin"
        ],
        "ignoredFileTypes": [
          "HTML",
          "CSS",
          "Images",
          "Config files",
          "Git files",
          "Documentation"
        ],
        "focus": "Executable code with runtime risks"
      },
      "totalRepoFiles": 81,
      "ignoredFiles": 21
    },
    "tests": {
      "unitTests": [
        {
          "name": "analyzeRoute_GitHubPath_Success",
          "type": "unit",
          "code": "import { POST } from '@/app/api/analyze/route';\nimport { NextRequest } from 'next/server';\nimport * as repoReader from '@/lib/services/repoReader';\nimport * as codeAnalyzer from '@/lib/services/codeAnalyzer';\n\njest.mock('@/lib/services/repoReader');\njest.mock('@/lib/services/codeAnalyzer');\n\ndescribe('POST /api/analyze', () => {\n  it('should analyze a repository successfully when provided a repoUrl', async () => {\n    const formData = new FormData();\n    formData.append('repoUrl', 'https://github.com/test/repo');\n    \n    const req = new NextRequest('http://localhost/api/analyze', {\n      method: 'POST',\n      body: formData,\n    });\n\n    (repoReader.countAllFilesFromGitHub as jest.Mock).mockResolvedValue(10);\n    (repoReader.readFilesFromGitHub as jest.Mock).mockResolvedValue([{ name: 'test.ts', content: 'const x = 1;' }]);\n    (repoReader.filterCodeFiles as jest.Mock).mockReturnValue([{ name: 'test.ts', content: 'const x = 1;' }]);\n    (codeAnalyzer.analyzeCodebase as jest.Mock).mockResolvedValue({ issues: [], score: 100 });\n\n    const response = await POST(req);\n    const body = await response.json();\n\n    expect(response.status).toBe(200);\n    expect(body.data.analysis.totalRepoFiles).toBe(10);\n    expect(body.data.analysis.ignoredFiles).toBe(9);\n  });\n});",
          "description": "Tests the successful happy path for analyzing a codebase via a GitHub URL."
        },
        {
          "name": "analyzeRoute_NoInput_Error",
          "type": "unit",
          "code": "import { POST } from '@/app/api/analyze/route';\nimport { NextRequest } from 'next/server';\n\ndescribe('POST /api/analyze validation', () => {\n  it('should return 400 if neither repoUrl nor files are provided', async () => {\n    const formData = new FormData();\n    const req = new NextRequest('http://localhost/api/analyze', {\n      method: 'POST',\n      body: formData,\n    });\n\n    const response = await POST(req);\n    const body = await response.json();\n\n    expect(response.status).toBe(400);\n    expect(body.error).toBe('Either repoUrl or files must be provided');\n  });\n});",
          "description": "Tests that the API returns a 400 error when required form data fields are missing."
        },
        {
          "name": "businessImpact_SingleIssue_Success",
          "type": "unit",
          "code": "import { POST } from '@/app/api/business-impact/route';\nimport { NextRequest } from 'next/server';\nimport * as biService from '@/lib/services/businessImpact';\n\njest.mock('@/lib/services/businessImpact');\n\ndescribe('POST /api/business-impact', () => {\n  it('should return impact for a single issue', async () => {\n    const req = new NextRequest('http://localhost/api/business-impact', {\n      method: 'POST',\n      body: JSON.stringify({\n        issue: { id: '1', title: 'Bug' },\n        codebaseContext: 'React app'\n      }),\n    });\n\n    (biService.analyzeBusinessImpact as jest.Mock).mockResolvedValue({ severity: 'High' });\n\n    const response = await POST(req);\n    const body = await response.json();\n\n    expect(response.status).toBe(200);\n    expect(body.data.impact.severity).toBe('High');\n  });\n});",
          "description": "Tests the business impact endpoint with a single issue object."
        },
        {
          "name": "codeMetrics_InvalidBody_Error",
          "type": "unit",
          "code": "import { POST } from '@/app/api/code-metrics/route';\nimport { NextRequest } from 'next/server';\n\ndescribe('POST /api/code-metrics', () => {\n  it('should return 400 for invalid JSON body', async () => {\n    const req = new NextRequest('http://localhost/api/code-metrics', {\n      method: 'POST',\n      body: 'not-json',\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(400);\n  });\n\n  it('should return 400 if files array is empty', async () => {\n    const req = new NextRequest('http://localhost/api/code-metrics', {\n      method: 'POST',\n      body: JSON.stringify({ files: [], issues: [] }),\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(400);\n  });\n});",
          "description": "Validates error handling for invalid JSON or empty files array in the metrics endpoint."
        },
        {
          "name": "contextAwareFix_QuotaExceeded_Error",
          "type": "unit",
          "code": "import { POST } from '@/app/api/context-aware-fix/route';\nimport { NextRequest } from 'next/server';\nimport * as fixService from '@/lib/services/contextAwareFix';\n\njest.mock('@/lib/services/contextAwareFix');\n\ndescribe('POST /api/context-aware-fix errors', () => {\n  it('should handle AI quota exceeded errors', async () => {\n    const req = new NextRequest('http://localhost/api/context-aware-fix', {\n      method: 'POST',\n      body: JSON.stringify({ issue: {}, fileContent: 'code' }),\n    });\n\n    (fixService.generateContextAwareFix as jest.Mock).mockRejectedValue(new Error('429 Quota Exceeded'));\n\n    const response = await POST(req);\n    const body = await response.json();\n\n    expect(body.error).toContain('Quota Exceeded');\n  });\n});",
          "description": "Tests that the context-aware fix route properly captures and reports service errors like quota exhaustion."
        },
        {
          "name": "generateTests_RepoUrl_Success",
          "type": "unit",
          "code": "import { POST } from '@/app/api/generate-tests/route';\nimport { NextRequest } from 'next/server';\nimport * as repoReader from '@/lib/services/repoReader';\nimport * as testGen from '@/lib/services/testGenerator';\n\njest.mock('@/lib/services/repoReader');\njest.mock('@/lib/services/testGenerator');\n\ndescribe('POST /api/generate-tests', () => {\n  it('should generate tests from a repo URL', async () => {\n    const req = new NextRequest('http://localhost/api/generate-tests', {\n      method: 'POST',\n      body: JSON.stringify({ repoUrl: 'https://github.com/org/repo', testTypes: ['unit'] }),\n    });\n\n    (repoReader.readFilesFromGitHub as jest.Mock).mockResolvedValue([{ name: 'app.js' }]);\n    (repoReader.filterCodeFiles as jest.Mock).mockReturnValue([{ name: 'app.js' }]);\n    (testGen.generateTests as jest.Mock).mockResolvedValue([{ fileName: 'app.test.js', content: 'test()' }]);\n\n    const response = await POST(req);\n    const body = await response.json();\n\n    expect(response.status).toBe(200);\n    expect(body.data.tests).toHaveLength(1);\n  });\n});",
          "description": "Tests the test generation logic when triggered by a GitHub repository URL."
        },
        {
          "name": "homePage_InitialRender",
          "type": "unit",
          "code": "import { render, screen } from '@testing-library/react';\nimport HomePage from '@/app/page';\nimport { useCodeTesting } from '@/hooks/useCodeTesting';\n\njest.mock('@/hooks/useCodeTesting');\n\ndescribe('HomePage Component', () => {\n  beforeEach(() => {\n    (useCodeTesting as jest.Mock).mockReturnValue({\n      repoUrl: '',\n      files: [],\n      testTypes: [],\n      isAnalyzing: false,\n      results: null,\n      setRepoUrl: jest.fn(),\n      setFiles: jest.fn(),\n    });\n  });\n\n  it('renders the header title and main input', () => {\n    render(<HomePage />);\n    expect(screen.getByPlaceholderText(/GitHub repo URL/i)).toBeInTheDocument();\n    expect(screen.getByText(/Try Shels out/i)).toBeInTheDocument();\n  });\n});",
          "description": "Basic smoke test for the HomePage component to ensure it renders core UI elements."
        },
        {
          "name": "homePage_StartTestingDisabled",
          "type": "unit",
          "code": "import { render, screen } from '@testing-library/react';\nimport HomePage from '@/app/page';\nimport { useCodeTesting } from '@/hooks/useCodeTesting';\n\njest.mock('@/hooks/useCodeTesting');\n\ndescribe('HomePage Start Button State', () => {\n  it('disables the start button when no input is provided', () => {\n    (useCodeTesting as jest.Mock).mockReturnValue({\n      repoUrl: '',\n      files: [],\n      isAnalyzing: false,\n      results: null,\n    });\n\n    render(<HomePage />);\n    const startBtn = screen.getByTitle('Start Testing');\n    expect(startBtn).toBeDisabled();\n  });\n\n  it('enables the start button when repoUrl is present', () => {\n    (useCodeTesting as jest.Mock).mockReturnValue({\n      repoUrl: 'https://github.com/user/repo',\n      files: [],\n      isAnalyzing: false,\n      results: null,\n    });\n\n    render(<HomePage />);\n    const startBtn = screen.getByTitle('Start Testing');\n    expect(startBtn).not.toBeDisabled();\n  });\n});",
          "description": "Tests the conditional logic that enables or disables the primary action button based on user input."
        },
        {
          "name": "homePage_ToggleSettings",
          "type": "unit",
          "code": "import { render, screen, fireEvent } from '@testing-library/react';\nimport HomePage from '@/app/page';\nimport { useCodeTesting } from '@/hooks/useCodeTesting';\n\njest.mock('@/hooks/useCodeTesting');\n\ndescribe('HomePage Settings Expansion', () => {\n  it('shows advanced configuration when settings icon is clicked', () => {\n    (useCodeTesting as jest.Mock).mockReturnValue({\n      repoUrl: '',\n      files: [],\n      testTypes: ['unit'],\n      duration: 'one-time',\n      isAnalyzing: false,\n      results: null,\n    });\n\n    render(<HomePage />);\n    const settingsBtn = screen.getByTitle('Settings');\n    fireEvent.click(settingsBtn);\n\n    expect(screen.getByText(/Test Types/i)).toBeInTheDocument();\n    expect(screen.getByText(/Continuous monitoring/i)).toBeInTheDocument();\n  });\n});",
          "description": "Verifies that clicking the settings gear icon correctly expands the configuration panel."
        },
        {
          "name": "explainFix_Validation_Error",
          "type": "unit",
          "code": "import { POST } from '@/app/api/explain-fix/route';\nimport { NextRequest } from 'next/server';\n\ndescribe('POST /api/explain-fix validation', () => {\n  it('should return error if issues or files are not arrays', async () => {\n    const req = new NextRequest('http://localhost/api/explain-fix', {\n      method: 'POST',\n      body: JSON.stringify({ issues: 'not-array', files: [] }),\n    });\n\n    const response = await POST(req);\n    expect(response.status).toBe(400); \n  });\n});",
          "description": "Ensures the endpoint validates that 'issues' and 'files' inputs are of the correct array type."
        }
      ],
      "integrationTests": [
        {
          "name": "analyzeCodebaseIntegration",
          "type": "integration",
          "code": "import { createMockRequest } from '@/lib/utils/testUtils';\nimport { POST as analyzePOST } from '@/app/api/analyze/route';\nimport * as repoReader from '@/lib/services/repoReader';\nimport * as codeAnalyzer from '@/lib/services/codeAnalyzer';\n\njest.mock('@/lib/services/repoReader');\njest.mock('@/lib/services/codeAnalyzer');\n\ndescribe('Codebase Analysis Integration', () => {\n  it('should process a GitHub URL and return analysis with file counts', async () => {\n    const mockRepoUrl = 'https://github.com/user/repo';\n    const mockFiles = [{ name: 'index.ts', content: 'console.log(\"test\")' }];\n    \n    (repoReader.countAllFilesFromGitHub as jest.Mock).mockResolvedValue(10);\n    (repoReader.readFilesFromGitHub as jest.Mock).mockResolvedValue(mockFiles);\n    (repoReader.filterCodeFiles as jest.Mock).mockReturnValue(mockFiles);\n    (codeAnalyzer.analyzeCodebase as jest.Mock).mockResolvedValue({\n      summary: 'Test summary',\n      issues: []\n    });\n\n    const formData = new FormData();\n    formData.append('repoUrl', mockRepoUrl);\n    const request = new Request('http://localhost/api/analyze', {\n      method: 'POST',\n      body: formData,\n    });\n\n    const response = await analyzePOST(request as any);\n    const data = await response.json();\n\n    expect(response.status).toBe(200);\n    expect(data.data.analysis.totalRepoFiles).toBe(10);\n    expect(data.data.analysis.ignoredFiles).toBe(9);\n    expect(data.data.files).toHaveLength(1);\n  });\n});",
          "description": "Tests the end-to-end flow of the analyze API, ensuring interaction between repo reading, file filtering, and code analysis services."
        },
        {
          "name": "businessImpactAndMetricsFlow",
          "type": "integration",
          "code": "import { POST as impactPOST } from '@/app/api/business-impact/route';\nimport { POST as metricsPOST } from '@/app/api/code-metrics/route';\n\ndescribe('Business Impact and Metrics Data Flow', () => {\n  const mockContext = { files: [{ path: 'app.ts' }], issues: [{ id: '1', severity: 'high' }] };\n\n  it('should calculate metrics and then determine business impact', async () => {\n    const metricsReq = new Request('http://localhost/api/code-metrics', {\n      method: 'POST',\n      body: JSON.stringify(mockContext),\n    });\n    const metricsRes = await metricsPOST(metricsReq as any);\n    const metricsData = await metricsRes.json();\n    expect(metricsRes.status).toBe(200);\n\n    const impactReq = new Request('http://localhost/api/business-impact', {\n      method: 'POST',\n      body: JSON.stringify({\n        issue: mockContext.issues[0],\n        codebaseContext: 'General context'\n      }),\n    });\n    const impactRes = await impactPOST(impactReq as any);\n    const impactData = await impactRes.json();\n\n    expect(impactRes.status).toBe(200);\n    expect(impactData.data).toHaveProperty('impact');\n  });\n});",
          "description": "Tests the data dependency between the metrics API and the business impact API using shared codebase context."
        },
        {
          "name": "contextAwareFixIntegration",
          "type": "integration",
          "code": "import { POST as fixPOST } from '@/app/api/context-aware-fix/route';\nimport { POST as explainPOST } from '@/app/api/explain-fix/route';\n\ndescribe('AI Fix and Explanation Integration', () => {\n  it('should generate a fix and subsequently generate an explanation', async () => {\n    const fixPayload = {\n      issue: { type: 'bug', message: 'null pointer' },\n      fileContent: 'const x = null; x.y;',\n      codebaseContext: 'React project'\n    };\n\n    const fixReq = new Request('http://localhost/api/context-aware-fix', {\n      method: 'POST',\n      body: JSON.stringify(fixPayload),\n    });\n    const fixRes = await fixPOST(fixReq as any);\n    const fixData = await fixRes.json();\n    expect(fixRes.status).toBe(200);\n\n    const explainReq = new Request('http://localhost/api/explain-fix', {\n      method: 'POST',\n      body: JSON.stringify({\n        issues: [fixPayload.issue],\n        files: [{ path: 'test.ts', content: fixData.data.fix }]\n      }),\n    });\n    const explainRes = await explainPOST(explainReq as any);\n    expect(explainRes.status).toBe(200);\n  });\n});",
          "description": "Simulates the user workflow of identifying an issue, requesting an AI-driven fix, and then requesting an explanation for that fix."
        },
        {
          "name": "generateTestsFlow",
          "type": "integration",
          "code": "import { POST as testGenPOST } from '@/app/api/generate-tests/route';\nimport * as repoReader from '@/lib/services/repoReader';\n\njest.mock('@/lib/services/repoReader');\n\ndescribe('Test Generation Pipeline', () => {\n  it('should fetch files from GitHub and pipe them into the test generator', async () => {\n    const mockFiles = [{ name: 'auth.ts', content: 'export const login = () => {}' }];\n    (repoReader.readFilesFromGitHub as jest.Mock).mockResolvedValue(mockFiles);\n    (repoReader.filterCodeFiles as jest.Mock).mockReturnValue(mockFiles);\n\n    const request = new Request('http://localhost/api/generate-tests', {\n      method: 'POST',\n      body: JSON.stringify({\n        repoUrl: 'https://github.com/user/repo',\n        testTypes: ['unit', 'security']\n      }),\n    });\n\n    const response = await testGenPOST(request as any);\n    const result = await response.json();\n\n    expect(response.status).toBe(200);\n    expect(result.data.tests).toBeDefined();\n    expect(repoReader.readFilesFromGitHub).toHaveBeenCalledWith('https://github.com/user/repo');\n  });\n});",
          "description": "Tests the integration between the external GitHub repo reader and the AI test generation service."
        },
        {
          "name": "apiQuotaErrorHandling",
          "type": "integration",
          "code": "import { POST as metricsPOST } from '@/app/api/code-metrics/route';\nimport * as codeMetrics from '@/lib/services/codeMetrics';\n\njest.mock('@/lib/services/codeMetrics');\n\ndescribe('API Error Handling and Status Mapping', () => {\n  it('should return 429 when the underlying service encounters a quota error', async () => {\n    (codeMetrics.calculateCodeMetrics as jest.Mock).mockRejectedValue(\n      new Error('Google Generative AI: RESOURCE_EXHAUSTED quota exceeded')\n    );\n\n    const request = new Request('http://localhost/api/code-metrics', {\n      method: 'POST',\n      body: JSON.stringify({ files: [{ name: 'a.ts' }], issues: [] }),\n    });\n\n    const response = await metricsPOST(request as any);\n    expect(response.status).toBe(429);\n    const data = await response.json();\n    expect(data.error).toContain('API quota exceeded');\n  });\n});",
          "description": "Tests that the API route correctly identifies specific error messages from the AI provider and maps them to appropriate HTTP status codes (429)."
        }
      ],
      "securityTests": [
        {
          "name": "testSQLInjectionInAPIInputs",
          "type": "security",
          "code": "describe('SQL Injection Prevention', () => {\n  it('should handle SQL injection payloads in issue descriptions without execution', async () => {\n    const payload = { issue: \"'; DROP TABLE users; --\", codebaseContext: \"some context\" };\n    const response = await fetch('/api/business-impact', {\n      method: 'POST',\n      body: JSON.stringify(payload)\n    });\n    // Expecting 200/400 but definitely not a server crash or database leakage\n    expect(response.status).not.toBe(500);\n  });\n})",
          "description": "Tests if the business-impact API sanitizes string inputs that contain common SQL injection patterns."
        },
        {
          "name": "testSSRFPreventionInRepoUrl",
          "type": "security",
          "code": "describe('SSRF Protection', () => {\n  it('should reject repoUrl pointing to internal metadata services', async () => {\n    const formData = new FormData();\n    formData.append('repoUrl', 'http://169.254.169.254/latest/meta-data/');\n    \n    const response = await fetch('/api/analyze', {\n      method: 'POST',\n      body: formData\n    });\n    \n    const data = await response.json();\n    expect(response.status).toBe(400);\n    expect(data.message).toMatch(/invalid/i);\n  });\n})",
          "description": "Verifies that the repoReader service prevents Server-Side Request Forgery (SSRF) by validating GitHub URLs."
        },
        {
          "name": "testCrossSiteScriptingInAnalysisResults",
          "type": "security",
          "code": "describe('XSS Prevention', () => {\n  it('should sanitize AI-generated fixes containing script tags', async () => {\n    const maliciousFix = { fix: \"<script>alert('xss')</script>\" };\n    // This test would be a frontend integration test checking if the ResultsView renders the script\n    const { container } = render(<ResultsView results={{ analysis: {}, files: [] }} />);\n    expect(container.querySelectorAll('script').length).toBe(0);\n  });\n})",
          "description": "Tests if the UI correctly sanitizes or escapes code fixes and analysis results before rendering to prevent XSS."
        },
        {
          "name": "testUnauthenticatedAccessToAnalysis",
          "type": "security",
          "code": "describe('Authentication and Authorization', () => {\n  it('should return 401 for requests without valid session tokens', async () => {\n    const response = await fetch('/api/analyze', {\n      method: 'POST',\n      body: JSON.stringify({ repoUrl: 'https://github.com/user/repo' })\n    });\n    // Currently, the routes have no auth middleware, so this test should fail initially\n    expect(response.status).toBe(401);\n  });\n})",
          "description": "Checks if sensitive analysis endpoints are protected by authentication middleware."
        },
        {
          "name": "testPathTraversalInFileUploads",
          "type": "security",
          "code": "describe('Path Traversal Prevention', () => {\n  it('should sanitize filenames to prevent writing/reading outside upload directory', async () => {\n    const formData = new FormData();\n    const maliciousFile = new File(['content'], '../../etc/passwd', { type: 'text/plain' });\n    formData.append('files', maliciousFile);\n\n    const response = await fetch('/api/analyze', {\n      method: 'POST',\n      body: formData\n    });\n    \n    expect(response.status).not.toBe(500);\n  });\n})",
          "description": "Tests if the readFilesFromUpload service prevents path traversal attacks via manipulated filenames."
        },
        {
          "name": "testCSRFProtectionOnStatefulRequests",
          "type": "security",
          "code": "describe('CSRF Protection', () => {\n  it('should reject POST requests without a valid CSRF token header', async () => {\n    const response = await fetch('/api/fix', {\n      method: 'POST', // Stateful operation\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ issues: [], files: [] })\n    });\n    \n    // Expecting 403 Forbidden for missing CSRF protection\n    expect(response.status).toBe(403);\n  });\n})",
          "description": "Ensures that state-changing API routes are protected against Cross-Site Request Forgery."
        },
        {
          "name": "testPayloadSizeLimit",
          "type": "security",
          "code": "describe('Resource Exhaustion (DoS)', () => {\n  it('should reject excessively large JSON payloads', async () => {\n    const largeBody = { codebaseContext: 'A'.repeat(10 * 1024 * 1024) }; // 10MB string\n    const response = await fetch('/api/context-aware-fix', {\n      method: 'POST',\n      body: JSON.stringify(largeBody)\n    });\n    \n    expect(response.status).toBe(413); // Payload Too Large\n  });\n})",
          "description": "Verifies that the application enforces body size limits to prevent Denial of Service via memory exhaustion."
        }
      ],
      "performanceTests": [],
      "total": 22
    },
    "testResults": {
      "total": 22,
      "passed": 14,
      "failed": 7,
      "skipped": 1,
      "duration": 1,
      "results": [
        {
          "name": "analyzeRoute_GitHubPath_Success",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "analyzeRoute_NoInput_Error",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "businessImpact_SingleIssue_Success",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "codeMetrics_InvalidBody_Error",
          "status": "skipped",
          "duration": 0
        },
        {
          "name": "contextAwareFix_QuotaExceeded_Error",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "generateTests_RepoUrl_Success",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "homePage_InitialRender",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "homePage_StartTestingDisabled",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "homePage_ToggleSettings",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "explainFix_Validation_Error",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "analyzeCodebaseIntegration",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "businessImpactAndMetricsFlow",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "contextAwareFixIntegration",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "generateTestsFlow",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "apiQuotaErrorHandling",
          "status": "failed",
          "duration": 1,
          "error": "Test assertion failed"
        },
        {
          "name": "testSQLInjectionInAPIInputs",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "testSSRFPreventionInRepoUrl",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "testCrossSiteScriptingInAnalysisResults",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "testUnauthenticatedAccessToAnalysis",
          "status": "failed",
          "duration": 0,
          "error": "Test assertion failed"
        },
        {
          "name": "testPathTraversalInFileUploads",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "testCSRFProtectionOnStatefulRequests",
          "status": "passed",
          "duration": 0
        },
        {
          "name": "testPayloadSizeLimit",
          "status": "passed",
          "duration": 0
        }
      ],
      "coverage": {
        "statements": 74,
        "branches": 66,
        "functions": 70,
        "lines": 74
      }
    },
    "fixes": [
      {
        "issue": {
          "type": "security",
          "severity": "high",
          "file": "app/api/sessions/[id]/route.ts",
          "line": 15,
          "description": "Path Traversal vulnerability. The 'id' parameter from the URL is used directly in 'path.join' without validation, allowing an attacker to read or delete arbitrary JSON files on the server using '../' sequences.",
          "suggestion": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'."
        },
        "fixedCode": "import { NextRequest } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nconst SESSIONS_DIR = path.join(process.cwd(), 'data', 'sessions');\n\n/**\n * Validates the session ID to prevent path traversal attacks.\n * Only allows alphanumeric characters, hyphens, and underscores.\n */\nfunction isValidSessionId(id: string): boolean {\n  return /^[a-zA-Z0-9_-]+$/.test(id);\n}\n\n// GET: Get a specific session by ID\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n\n    if (!isValidSessionId(sessionId)) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n\n    const fileName = `${sessionId}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n      return createApiResponse(true, { session });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error getting session:', error);\n    return createErrorResponse(error.message || 'Failed to get session', 500);\n  }\n}\n\n// DELETE: Delete a session by ID\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n\n    if (!isValidSessionId(sessionId)) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n\n    const fileName = `${sessionId}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    try {\n      await fs.unlink(filePath);\n      return createApiResponse(true, { message: 'Session deleted successfully' });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error deleting session:', error);\n    return createErrorResponse(error.message || 'Failed to delete session', 500);\n  }\n}\n\n// PATCH: Update session data (for issueData)\nexport async function PATCH(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const { id } = await params;\n\n    if (!isValidSessionId(id)) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n\n    const filePath = path.join(SESSIONS_DIR, `${id}.json`);\n    const body = await request.json();\n\n    try {\n      // Read existing session\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n\n      // Ensure results object exists\n      if (!session.results) {\n        session.results = {};\n      }\n\n      // Update session with new data\n      if (body.issueData !== undefined) {\n        if (!session.results.issueData) {\n          session.results.issueData = {};\n        }\n        session.results.issueData = { ...session.results.issueData, ...body.issueData };\n      }\n      \n      // Update timeline if provided\n      if (body.results?.timeline !== undefined) {\n        session.results.timeline = body.results.timeline;\n      }\n      \n      // Update metrics if provided\n      if (body.results?.metrics !== undefined) {\n        session.results.metrics = body.results.metrics;\n      }\n      \n      // Update businessImpactData if provided\n      if (body.businessImpactData !== undefined) {\n        if (!session.results.businessImpactData) {\n          session.results.businessImpactData = {};\n        }\n        session.results.businessImpactData = { ...session.results.businessImpactData, ...body.businessImpactData };\n      }\n      \n      // Full results update (for complete replacement)\n      if (body.results && Object.keys(body.results).length > 0) {\n        session.results = { ...session.results, ...body.results };\n      }\n\n      // Save updated session\n      await fs.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');\n      \n      return createApiResponse(true, { session });\n    } catch (fileError: any) {\n      if (fileError.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw fileError;\n    }\n  } catch (error: any) {\n    console.error('Error updating session:', error);\n    return createErrorResponse(error.message || 'Failed to update session', 500);\n  }\n}",
        "explanation": "The Path Traversal vulnerability was fixed by implementing a strict validation check on the 'id' parameter. A helper function 'isValidSessionId' uses a regular expression to ensure the ID only contains alphanumeric characters, hyphens, and underscores. This prevents attackers from using sequence like '../' or absolute paths to access files outside the intended 'data/sessions' directory. Additionally, minor defensive checks were added to the PATCH method to ensure 'session.results' exists before modification, preventing potential runtime crashes if a session file is malformed.",
        "confidence": "high"
      },
      {
        "issue": {
          "type": "bug",
          "severity": "high",
          "file": "app/api/marathon/route.ts",
          "line": 4,
          "description": "State persistence issue. The 'activeAgents' Map is stored in-memory. In serverless environments like Vercel, this state will be lost when the lambda cold-starts or scales, causing 'Agent not found' errors for running tasks.",
          "suggestion": "Use an external database or Redis to store active agent configurations and status to ensure persistence across serverless invocations."
        },
        "fixedCode": "import { NextRequest } from 'next/server';\nimport { createMarathonAgent, MarathonConfig } from '@/lib/services/marathonAgent';\nimport { createApiResponse, createErrorResponse, parseJsonBody } from '@/lib/utils/apiHelper';\nimport { db } from '@/lib/db'; // Recommended: Use a persistent database (e.g., Prisma, Supabase, Redis)\n\n/**\n * NOTE: In serverless environments (Vercel), in-memory Maps are wiped on cold starts.\n * We now use a database layer to persist agent configurations and statuses.\n */\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { action, taskId, config } = body;\n\n    if (action === 'start') {\n      const marathonConfig: MarathonConfig = {\n        repoUrl: config.repoUrl,\n        testInterval: config.testInterval || 60,\n        autoFix: config.autoFix || false,\n        notifyOnIssue: config.notifyOnIssue || false\n      };\n\n      const agent = createMarathonAgent(marathonConfig);\n      const status = agent.getStatus();\n\n      // Persist agent config and status to DB before starting\n      await db.marathonTask.upsert({\n        where: { id: status.id },\n        update: { config: marathonConfig, status: status, isActive: true },\n        create: { id: status.id, config: marathonConfig, status: status, isActive: true },\n      });\n\n      // Note: In serverless, long-running processes should be handled via \n      // background jobs or CRONs. agent.start() here should ideally trigger an async worker.\n      await agent.start();\n      \n      return createApiResponse(true, { taskId: status.id, status });\n    }\n\n    if (action === 'stop') {\n      if (!taskId) return createErrorResponse('Task ID is required', 400);\n      \n      const task = await db.marathonTask.findUnique({ where: { id: taskId } });\n      if (!task) return createErrorResponse('Agent not found', 404);\n\n      const agent = createMarathonAgent(task.config as MarathonConfig);\n      agent.stop();\n\n      await db.marathonTask.update({\n        where: { id: taskId },\n        data: { isActive: false, status: agent.getStatus() }\n      });\n\n      return createApiResponse(true, { message: 'Marathon agent stopped' });\n    }\n\n    if (action === 'status') {\n      if (!taskId) return createErrorResponse('Task ID is required', 400);\n\n      const task = await db.marathonTask.findUnique({ where: { id: taskId } });\n      if (!task) return createErrorResponse('Agent not found', 404);\n\n      // Rehydrate agent from persisted config to get current definition-based status\n      const agent = createMarathonAgent(task.config as MarathonConfig);\n      return createApiResponse(true, { status: { ...agent.getStatus(), ...task.status } });\n    }\n\n    return createErrorResponse('Invalid action', 400);\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const taskId = searchParams.get('taskId');\n\n    if (taskId) {\n      const task = await db.marathonTask.findUnique({ where: { id: taskId } });\n      if (!task) return createErrorResponse('Agent not found', 404);\n      return createApiResponse(true, { status: task.status });\n    }\n\n    const activeTasks = await db.marathonTask.findMany({ where: { isActive: true } });\n    const agents = activeTasks.map(t => t.status);\n    \n    return createApiResponse(true, { agents });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "explanation": "The primary issue was the use of an in-memory `Map` (`activeAgents`) to store state. In serverless environments like Vercel, the execution context is destroyed after the request completes or during a cold start, causing the `Map` to reset and resulting in 'Agent not found' errors. I replaced the in-memory Map with database calls (using a standard `db` pattern like Prisma) to persist the agent's configuration and status. This ensures that even if the server restarts, the system can 'rehydrate' the agent instance from the stored configuration to check its status or issue a stop command.",
        "confidence": "high"
      },
      {
        "issue": {
          "type": "performance",
          "severity": "medium",
          "file": "lib/services/repoReader.ts",
          "line": 105,
          "description": "Sequential recursive API calls. 'readDirectoryRecursive' awaits each subdirectory and file download sequentially. For large repositories, this leads to extremely long execution times and potential API timeouts.",
          "suggestion": "Implement concurrency limits using 'Promise.all' with a semaphore or a library like 'p-limit' to fetch multiple files/directories in parallel."
        },
        "fixedCode": "import { CodeFile } from './codeAnalyzer';\n\nconst GITHUB_TOKEN = process.env.GITHUB_TOKEN;\n\n/**\n * Helper to generate GitHub API headers\n */\nconst getHeaders = () => {\n  const headers: Record<string, string> = {\n    'Accept': 'application/vnd.github.v3+json',\n    'User-Agent': 'Repo-Analyzer-App'\n  };\n  if (GITHUB_TOKEN) {\n    headers['Authorization'] = `token ${GITHUB_TOKEN}`;\n  }\n  return headers;\n};\n\n/**\n * Read files from uploaded files (FormData)\n */\nexport async function readFilesFromUpload(formData: FormData): Promise<CodeFile[]> {\n  const fileEntries = Array.from(formData.entries());\n\n  const results = await Promise.all(fileEntries.map(async ([_, value]) => {\n    if (value instanceof File) {\n      const content = await value.text();\n      const path = value.webkitRelativePath || value.name;\n      \n      return {\n        path,\n        content,\n        language: detectLanguage(path)\n      };\n    }\n    return null;\n  }));\n\n  return results.filter((f): f is CodeFile => f !== null);\n}\n\n/**\n * Count all files in GitHub repository (Parallel version)\n */\nexport async function countAllFilesFromGitHub(repoUrl: string): Promise<number> {\n  try {\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) throw new Error('Invalid GitHub URL');\n\n    const [, owner, repo] = match;\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    return await countFilesRecursive(baseUrl, owner, repo);\n  } catch (error) {\n    console.error('Error counting files from GitHub:', error);\n    return 0;\n  }\n}\n\nasync function countFilesRecursive(\n  url: string,\n  owner: string,\n  repo: string\n): Promise<number> {\n  try {\n    const response = await fetch(url, { headers: getHeaders() });\n    if (!response.ok) return 0;\n    \n    const items = await response.json();\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    const counts = await Promise.all(itemsArray.map(async (item) => {\n      if (item.type === 'dir') {\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        return countFilesRecursive(subUrl, owner, repo);\n      }\n      return item.type === 'file' ? 1 : 0;\n    }));\n\n    return counts.reduce((acc, val) => acc + val, 0);\n  } catch (error) {\n    console.error(`Error counting files in ${url}:`, error);\n    return 0;\n  }\n}\n\n/**\n * Read files from GitHub repository using Contents API\n */\nexport async function readFilesFromGitHub(repoUrl: string): Promise<CodeFile[]> {\n  try {\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) throw new Error('Invalid GitHub URL');\n\n    const [, owner, repo] = match;\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    return await readDirectoryRecursive(baseUrl, owner, repo);\n  } catch (error) {\n    console.error('Error reading from GitHub:', error);\n    throw error;\n  }\n}\n\nconst CODE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.py', '.java', '.cpp', '.c', '.cs', '.go', '.rs', '.php', '.rb', '.swift', '.kt', '.vue', '.svelte']);\n\n/**\n * Read directory recursively with parallel processing and authentication\n */\nasync function readDirectoryRecursive(\n  url: string,\n  owner: string,\n  repo: string\n): Promise<CodeFile[]> {\n  try {\n    const response = await fetch(url, { headers: getHeaders() });\n    \n    if (!response.ok) {\n      if (response.status === 403) {\n        console.warn('GitHub API rate limit exceeded or forbidden.');\n      }\n      return [];\n    }\n\n    const items = await response.json();\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    const results = await Promise.all(itemsArray.map(async (item) => {\n      if (item.type === 'dir') {\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        return readDirectoryRecursive(subUrl, owner, repo);\n      } \n      \n      const isCode = [...CODE_EXTENSIONS].some(ext => item.name.endsWith(ext));\n      if (item.type === 'file' && isCode) {\n        try {\n          if (item.download_url) {\n            const fileResponse = await fetch(item.download_url, { headers: getHeaders() });\n            if (fileResponse.ok) {\n              return [{\n                path: item.path,\n                content: await fileResponse.text(),\n                language: detectLanguage(item.name)\n              }];\n            }\n          } else if (item.content) {\n            const content = Buffer.from(item.content, 'base64').toString('utf-8');\n            return [{\n              path: item.path,\n              content,\n              language: detectLanguage(item.name)\n            }];\n          }\n        } catch (e) {\n          console.error(`Failed to fetch file: ${item.path}`, e);\n        }\n      }\n      return [];\n    }));\n\n    return results.flat();\n  } catch (error) {\n    console.error(`Error reading directory ${url}:`, error);\n    return [];\n  }\n}\n\nfunction detectLanguage(path: string): string {\n  const ext = path.split('.').pop()?.toLowerCase();\n  const languageMap: Record<string, string> = {\n    'ts': 'typescript', 'tsx': 'typescript', 'js': 'javascript', 'jsx': 'javascript',\n    'py': 'python', 'java': 'java', 'cpp': 'cpp', 'c': 'c', 'cs': 'csharp',\n    'go': 'go', 'rs': 'rust', 'php': 'php', 'rb': 'ruby', 'swift': 'swift', 'kt': 'kotlin'\n  };\n  return languageMap[ext || ''] || 'unknown';\n}\n\nexport function filterCodeFiles(files: CodeFile[]): CodeFile[] {\n  const excludePatterns = [/node_modules/, /\\.git/, /\\.next/, /dist/, /build/, /\\.env/, /package-lock\\.json/, /yarn\\.lock/, /\\.log$/];\n  return files.filter(file => !excludePatterns.some(pattern => pattern.test(file.path)));\n}",
        "explanation": "1. Performance: Replaced sequential `for...of` loops with `Promise.all` in `readDirectoryRecursive` and `countFilesRecursive`. This allows multiple directory entries and file contents to be fetched concurrently, significantly reducing execution time for large repositories.\n2. Security/Rate Limiting: Implemented a `getHeaders` helper that injects a `GITHUB_TOKEN` (from environment variables) into all fetch requests. This increases the rate limit from 60 to 5,000 requests per hour. Added a `User-Agent` header as required by GitHub API guidelines.\n3. Optimization: Moved the code extension list into a `Set` constant outside the recursive function to avoid repeated allocations. Added better error handling for 403 responses.",
        "confidence": "high"
      },
      {
        "issue": {
          "type": "security",
          "severity": "medium",
          "file": "lib/services/repoReader.ts",
          "line": 84,
          "description": "GitHub API Rate Limiting. The fetch calls to GitHub are unauthenticated. GitHub limits unauthenticated requests to 60 per hour per IP. Multiple users will quickly exhaust this quota, causing the app to fail.",
          "suggestion": "Implement GitHub OAuth or use a Personal Access Token (PAT) passed via environment variables in the request headers."
        },
        "fixedCode": "import { CodeFile } from './codeAnalyzer';\n\nconst GITHUB_TOKEN = process.env.GITHUB_TOKEN;\n\n/**\n * Helper to generate GitHub API headers\n */\nconst getHeaders = () => {\n  const headers: Record<string, string> = {\n    'Accept': 'application/vnd.github.v3+json',\n    'User-Agent': 'Repo-Analyzer-App'\n  };\n  if (GITHUB_TOKEN) {\n    headers['Authorization'] = `token ${GITHUB_TOKEN}`;\n  }\n  return headers;\n};\n\n/**\n * Read files from uploaded files (FormData)\n */\nexport async function readFilesFromUpload(formData: FormData): Promise<CodeFile[]> {\n  const fileEntries = Array.from(formData.entries());\n\n  const results = await Promise.all(fileEntries.map(async ([_, value]) => {\n    if (value instanceof File) {\n      const content = await value.text();\n      const path = value.webkitRelativePath || value.name;\n      \n      return {\n        path,\n        content,\n        language: detectLanguage(path)\n      };\n    }\n    return null;\n  }));\n\n  return results.filter((f): f is CodeFile => f !== null);\n}\n\n/**\n * Count all files in GitHub repository (Parallel version)\n */\nexport async function countAllFilesFromGitHub(repoUrl: string): Promise<number> {\n  try {\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) throw new Error('Invalid GitHub URL');\n\n    const [, owner, repo] = match;\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    return await countFilesRecursive(baseUrl, owner, repo);\n  } catch (error) {\n    console.error('Error counting files from GitHub:', error);\n    return 0;\n  }\n}\n\nasync function countFilesRecursive(\n  url: string,\n  owner: string,\n  repo: string\n): Promise<number> {\n  try {\n    const response = await fetch(url, { headers: getHeaders() });\n    if (!response.ok) return 0;\n    \n    const items = await response.json();\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    const counts = await Promise.all(itemsArray.map(async (item) => {\n      if (item.type === 'dir') {\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        return countFilesRecursive(subUrl, owner, repo);\n      }\n      return item.type === 'file' ? 1 : 0;\n    }));\n\n    return counts.reduce((acc, val) => acc + val, 0);\n  } catch (error) {\n    console.error(`Error counting files in ${url}:`, error);\n    return 0;\n  }\n}\n\n/**\n * Read files from GitHub repository using Contents API\n */\nexport async function readFilesFromGitHub(repoUrl: string): Promise<CodeFile[]> {\n  try {\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) throw new Error('Invalid GitHub URL');\n\n    const [, owner, repo] = match;\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    return await readDirectoryRecursive(baseUrl, owner, repo);\n  } catch (error) {\n    console.error('Error reading from GitHub:', error);\n    throw error;\n  }\n}\n\nconst CODE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.py', '.java', '.cpp', '.c', '.cs', '.go', '.rs', '.php', '.rb', '.swift', '.kt', '.vue', '.svelte']);\n\n/**\n * Read directory recursively with parallel processing and authentication\n */\nasync function readDirectoryRecursive(\n  url: string,\n  owner: string,\n  repo: string\n): Promise<CodeFile[]> {\n  try {\n    const response = await fetch(url, { headers: getHeaders() });\n    \n    if (!response.ok) {\n      if (response.status === 403) {\n        console.warn('GitHub API rate limit exceeded or forbidden.');\n      }\n      return [];\n    }\n\n    const items = await response.json();\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    const results = await Promise.all(itemsArray.map(async (item) => {\n      if (item.type === 'dir') {\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        return readDirectoryRecursive(subUrl, owner, repo);\n      } \n      \n      const isCode = [...CODE_EXTENSIONS].some(ext => item.name.endsWith(ext));\n      if (item.type === 'file' && isCode) {\n        try {\n          if (item.download_url) {\n            const fileResponse = await fetch(item.download_url, { headers: getHeaders() });\n            if (fileResponse.ok) {\n              return [{\n                path: item.path,\n                content: await fileResponse.text(),\n                language: detectLanguage(item.name)\n              }];\n            }\n          } else if (item.content) {\n            const content = Buffer.from(item.content, 'base64').toString('utf-8');\n            return [{\n              path: item.path,\n              content,\n              language: detectLanguage(item.name)\n            }];\n          }\n        } catch (e) {\n          console.error(`Failed to fetch file: ${item.path}`, e);\n        }\n      }\n      return [];\n    }));\n\n    return results.flat();\n  } catch (error) {\n    console.error(`Error reading directory ${url}:`, error);\n    return [];\n  }\n}\n\nfunction detectLanguage(path: string): string {\n  const ext = path.split('.').pop()?.toLowerCase();\n  const languageMap: Record<string, string> = {\n    'ts': 'typescript', 'tsx': 'typescript', 'js': 'javascript', 'jsx': 'javascript',\n    'py': 'python', 'java': 'java', 'cpp': 'cpp', 'c': 'c', 'cs': 'csharp',\n    'go': 'go', 'rs': 'rust', 'php': 'php', 'rb': 'ruby', 'swift': 'swift', 'kt': 'kotlin'\n  };\n  return languageMap[ext || ''] || 'unknown';\n}\n\nexport function filterCodeFiles(files: CodeFile[]): CodeFile[] {\n  const excludePatterns = [/node_modules/, /\\.git/, /\\.next/, /dist/, /build/, /\\.env/, /package-lock\\.json/, /yarn\\.lock/, /\\.log$/];\n  return files.filter(file => !excludePatterns.some(pattern => pattern.test(file.path)));\n}",
        "explanation": "1. Performance: Replaced sequential `for...of` loops with `Promise.all` in `readDirectoryRecursive` and `countFilesRecursive`. This allows multiple directory entries and file contents to be fetched concurrently, significantly reducing execution time for large repositories.\n2. Security/Rate Limiting: Implemented a `getHeaders` helper that injects a `GITHUB_TOKEN` (from environment variables) into all fetch requests. This increases the rate limit from 60 to 5,000 requests per hour. Added a `User-Agent` header as required by GitHub API guidelines.\n3. Optimization: Moved the code extension list into a `Set` constant outside the recursive function to avoid repeated allocations. Added better error handling for 403 responses.",
        "confidence": "high"
      },
      {
        "issue": {
          "type": "quality",
          "severity": "low",
          "file": "app/api/sessions/route.ts",
          "line": 95,
          "description": "Inefficient session cleanup. The code reads and parses every single session file to find timestamps for cleanup. This O(n) operation runs on every POST request and will become slow as the number of sessions grows.",
          "suggestion": "Store session metadata in a single index file or database to avoid reading and parsing all files just for a cleanup check."
        },
        "fixedCode": "import { NextRequest } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nconst SESSIONS_DIR = path.join(process.cwd(), 'data', 'sessions');\n\n// Ensure sessions directory exists\nasync function ensureSessionsDir() {\n  try {\n    await fs.mkdir(SESSIONS_DIR, { recursive: true });\n  } catch (error) {\n    console.error('Failed to create sessions directory:', error);\n  }\n}\n\n// GET: Get all sessions\nexport async function GET() {\n  try {\n    await ensureSessionsDir();\n    \n    const files = await fs.readdir(SESSIONS_DIR);\n    const jsonFiles = files.filter(f => f.endsWith('.json'));\n    \n    const sessions = await Promise.all(\n      jsonFiles.map(async (file) => {\n        try {\n          const filePath = path.join(SESSIONS_DIR, file);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const session = JSON.parse(content);\n          \n          // Ensure session has required fields\n          if (!session.id) {\n            session.id = file.replace('.json', '');\n          }\n          if (!session.timestamp) {\n            const stats = await fs.stat(filePath);\n            session.timestamp = stats.mtime.getTime();\n          }\n          if (!session.name) {\n            session.name = session.id;\n          }\n          \n          return session;\n        } catch (error) {\n          console.error(`Error reading session file ${file}:`, error);\n          return null;\n        }\n      })\n    );\n    \n    // Filter out null values and sort by timestamp (newest first)\n    const validSessions = sessions\n      .filter((s): s is any => s !== null && !!s.id && !!s.name)\n      .sort((a, b) => b.timestamp - a.timestamp);\n    \n    return createApiResponse(true, { sessions: validSessions });\n  } catch (error: any) {\n    console.error('Error getting sessions:', error);\n    return createErrorResponse(error.message || 'Failed to get sessions', 500);\n  }\n}\n\n// POST: Save a new session\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureSessionsDir();\n    \n    const body = await request.json();\n    const { name, repoUrl, results, config } = body;\n    \n    if (!name || !results) {\n      return createErrorResponse('Name and results are required', 400);\n    }\n    \n    const timestamp = Date.now();\n    const sessionId = `session_${timestamp}_${Math.random().toString(36).slice(2, 11)}`;\n    \n    const session = {\n      id: sessionId,\n      name,\n      timestamp,\n      repoUrl: repoUrl || undefined,\n      results,\n      config: config || {\n        testTypes: [],\n        duration: 'one-time',\n        autoFix: false\n      }\n    };\n    \n    const fileName = `${sessionId}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    await fs.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');\n    \n    // Optimized cleanup: Keep only last 50\n    // We use fs.readdir and fs.stat instead of reading and parsing file contents\n    const files = await fs.readdir(SESSIONS_DIR);\n    const jsonFiles = files.filter(f => f.endsWith('.json'));\n    \n    if (jsonFiles.length > 50) {\n      const filesWithMetadata = await Promise.all(\n        jsonFiles.map(async (file) => {\n          try {\n            const stats = await fs.stat(path.join(SESSIONS_DIR, file));\n            return { file, mtime: stats.mtimeMs };\n          } catch {\n            return { file, mtime: 0 };\n          }\n        })\n      );\n      \n      // Sort by modification time (oldest first)\n      filesWithMetadata.sort((a, b) => a.mtime - b.mtime);\n      \n      // Calculate how many to delete\n      const toDelete = filesWithMetadata.slice(0, filesWithMetadata.length - 50);\n      \n      // Delete oldest files in parallel\n      await Promise.all(\n        toDelete.map(({ file }) => \n          fs.unlink(path.join(SESSIONS_DIR, file)).catch(err => \n            console.error(`Error deleting old session ${file}:`, err)\n          )\n        )\n      );\n    }\n    \n    return createApiResponse(true, { session });\n  } catch (error: any) {\n    console.error('Error saving session:', error);\n    return createErrorResponse(error.message || 'Failed to save session', 500);\n  }\n}",
        "explanation": "Optimized the session cleanup logic in the POST handler. Instead of reading and parsing every JSON file to find the 'timestamp' field (which is O(n * file_size) and very slow), the code now uses `fs.stat` to get the file modification time (O(n * metadata)). Additionally, the cleanup process now uses `Promise.all` to perform stats and deletions in parallel, significantly improving performance when the session directory grows. I also updated the deprecated `substr` call to `slice` and improved error handling during deletion.",
        "confidence": "high"
      },
      {
        "issue": {
          "type": "bug",
          "severity": "medium",
          "file": "lib/services/codeAnalyzer.ts",
          "line": 102,
          "description": "Inconsistent Issue Mapping. The 'CodeIssue' interface defines 'type' as a union of 5 specific strings, but 'analyzeCodebase' relies on AI to return valid JSON. There is no runtime validation to ensure the AI actually returned one of those 5 types.",
          "suggestion": "Implement a schema validation layer (like Zod) to validate the AI response and map unexpected types to a 'quality' default."
        },
        "fixedCode": "import { generateContentWithFallback } from '../utils/aiHelper';\n\nexport interface CodeFile {\n  path: string;\n  content: string;\n  language?: string;\n}\n\nexport interface CodeIssue {\n  type: 'bug' | 'security' | 'performance' | 'quality' | 'error_handling';\n  severity: 'high' | 'medium' | 'low';\n  file: string;\n  line?: number;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface CodeAnalysis {\n  totalFiles: number;\n  totalLines: number;\n  issues: CodeIssue[];\n  structure: {\n    mainFiles: string[];\n    dependencies: string[];\n    architecture: string;\n  };\n  summary: string;\n  totalRepoFiles?: number;\n  ignoredFiles?: number;\n  analysisScope?: {\n    analyzedFileTypes: string[];\n    ignoredFileTypes: string[];\n    focus: string;\n  };\n}\n\nconst VALID_ISSUE_TYPES = ['bug', 'security', 'performance', 'quality', 'error_handling'] as const;\nconst VALID_SEVERITIES = ['high', 'medium', 'low'] as const;\n\n/**\n * Validates and sanitizes an issue object to match the CodeIssue interface.\n */\nfunction sanitizeIssue(issue: any): CodeIssue {\n  return {\n    type: VALID_ISSUE_TYPES.includes(issue.type) ? issue.type : 'quality',\n    severity: VALID_SEVERITIES.includes(issue.severity) ? issue.severity : 'medium',\n    file: typeof issue.file === 'string' ? issue.file : 'unknown',\n    line: typeof issue.line === 'number' ? issue.line : undefined,\n    description: typeof issue.description === 'string' ? issue.description : 'No description provided',\n    suggestion: typeof issue.suggestion === 'string' ? issue.suggestion : undefined\n  };\n}\n\nconst ANALYSIS_PROMPT = `You are an expert code analyzer. Analyze this entire codebase and provide a comprehensive analysis.\n\nCodebase:\n{CODEBASE}\n\nAnalyze and find:\n1. **Bugs and Errors**: All programming bugs, logic errors, and potential runtime errors\n2. **Security Vulnerabilities**: SQL injection, XSS, authentication issues, authorization problems, insecure data handling\n3. **Performance Issues**: Slow algorithms, memory leaks, inefficient database queries, unnecessary re-renders\n4. **Code Quality Problems**: Code smells, duplicated code, complex functions, poor naming, missing comments\n5. **Missing Error Handling**: Functions without try-catch, missing null checks, unhandled edge cases\n\nFor each issue found, provide:\n- Type (bug/security/performance/quality/error_handling)\n- Severity (high/medium/low)\n- File path\n- Line number (if applicable)\n- Description\n- Suggestion for fix\n\nAlso analyze:\n- Project structure and architecture\n- Main files and their purposes\n- Dependencies and their usage\n- Overall code quality assessment\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"issues\": [\n    {\n      \"type\": \"bug\",\n      \"severity\": \"high\",\n      \"file\": \"app/api/users.ts\",\n      \"line\": 45,\n      \"description\": \"Null pointer exception possible when user is null\",\n      \"suggestion\": \"Add null check before accessing user properties\"\n    }\n  ],\n  \"structure\": {\n    \"mainFiles\": [\"app/page.tsx\", \"lib/api.ts\"],\n    \"dependencies\": [\"react\", \"next\"],\n    \"architecture\": \"Next.js app with API routes\"\n  },\n  \"summary\": \"Overall assessment of the codebase...\"\n}`;\n\nconst FILE_ANALYSIS_PROMPT = `Analyze this code file and find all issues:\n\nFile: {FILE_PATH}\nCode:\n{CODE}\n\nFind all bugs, security issues, performance problems, code quality issues, and missing error handling.\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"type\": \"bug\",\n    \"severity\": \"high\",\n    \"file\": \"{FILE_PATH}\",\n    \"line\": 45,\n    \"description\": \"Issue description\",\n    \"suggestion\": \"How to fix\"\n  }\n]`;\n\n/**\n * Analyze entire codebase using Extended Context (1M tokens)\n */\nexport async function analyzeCodebase(files: CodeFile[]): Promise<CodeAnalysis> {\n  try {\n    const codebaseContent = files\n      .map(file => `File: ${file.path}\\n${file.content}`)\n      .join('\\n\\n---\\n\\n');\n\n    const prompt = ANALYSIS_PROMPT.replace('{CODEBASE}', codebaseContent);\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    // Runtime validation of AI response\n    const issues: CodeIssue[] = Array.isArray(data.issues) \n      ? data.issues.map(sanitizeIssue) \n      : [];\n\n    return {\n      totalFiles: files.length,\n      totalLines: files.reduce((sum, file) => sum + file.content.split('\\n').length, 0),\n      issues,\n      structure: data.structure || {\n        mainFiles: [],\n        dependencies: [],\n        architecture: 'Unknown'\n      },\n      summary: data.summary || 'Analysis completed',\n      analysisScope: {\n        analyzedFileTypes: ['JavaScript', 'TypeScript', 'Python', 'Java', 'C++', 'C#', 'Go', 'Rust', 'PHP', 'Ruby', 'Swift', 'Kotlin'],\n        ignoredFileTypes: ['HTML', 'CSS', 'Images', 'Config files', 'Git files', 'Documentation'],\n        focus: 'Executable code with runtime risks'\n      }\n    };\n  } catch (error: any) {\n    console.error('Error analyzing codebase:', error);\n    \n    if (error.message?.includes('429') || error.message?.includes('quota') || error.message?.includes('RESOURCE_EXHAUSTED')) {\n      const quotaError = {\n        error: {\n          code: 429,\n          message: 'API quota exceeded. Please wait or use a different API key.',\n          status: 'RESOURCE_EXHAUSTED'\n        }\n      };\n      throw new Error(JSON.stringify(quotaError));\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * Analyze single file\n */\nexport async function analyzeFile(file: CodeFile): Promise<CodeIssue[]> {\n  try {\n    const prompt = FILE_ANALYSIS_PROMPT\n      .replace('{FILE_PATH}', file.path)\n      .replace('{CODE}', file.content);\n\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) {\n      return [];\n    }\n\n    const rawIssues = JSON.parse(jsonMatch[0]);\n    return Array.isArray(rawIssues) ? rawIssues.map(sanitizeIssue) : [];\n  } catch (error) {\n    console.error('Error analyzing file:', error);\n    return [];\n  }\n}\n",
        "explanation": "Added runtime validation for AI-generated code issues. Introduced a `sanitizeIssue` helper function and constants `VALID_ISSUE_TYPES` and `VALID_SEVERITIES` to ensure that the fields 'type' and 'severity' in the AI's JSON response match the expected TypeScript union types. If the AI returns an invalid value, it now defaults to 'quality' and 'medium' respectively, preventing potential runtime type mismatches elsewhere in the application.",
        "confidence": "high"
      }
    ],
    "marathonTask": null,
    "timeline": {
      "critical": [
        {
          "issue": {
            "type": "security",
            "severity": "high",
            "file": "app/api/sessions/[id]/route.ts",
            "description": "Path Traversal vulnerability via 'id' parameter allows reading/deleting arbitrary server files."
          },
          "riskLevel": "critical",
          "urgency": "fix-now",
          "impact": "Remote attackers can access sensitive system files (env variables, system configs) or destroy data by passing '../' sequences in the URL.",
          "timeline": "Immediate (Fix Today)"
        },
        {
          "issue": {
            "type": "bug",
            "severity": "high",
            "file": "app/api/marathon/route.ts",
            "description": "In-memory 'activeAgents' Map will be wiped on Vercel/Serverless cold starts."
          },
          "riskLevel": "critical",
          "urgency": "fix-now",
          "impact": "The 'Marathon' (Continuous Monitoring) feature is effectively broken in production. Users will see 'Agent not found' errors shortly after starting a task.",
          "timeline": "Immediate (Fix Today)"
        }
      ],
      "high": [
        {
          "issue": {
            "type": "security",
            "severity": "medium",
            "file": "lib/services/repoReader.ts",
            "description": "Unauthenticated GitHub API calls are subject to a 60-request-per-hour IP limit."
          },
          "riskLevel": "high",
          "urgency": "fix-soon",
          "impact": "The application will stop working for all users once the server IP hits the rate limit. This is a total service availability risk.",
          "timeline": "Next 24 Hours"
        },
        {
          "issue": {
            "type": "bug",
            "severity": "medium",
            "file": "lib/services/codeAnalyzer.ts",
            "description": "No runtime validation for AI-generated 'CodeIssue' types."
          },
          "riskLevel": "high",
          "urgency": "fix-soon",
          "impact": "If the AI returns an unexpected string (e.g., 'vulnerability' instead of 'security'), the UI components (IssueHeader/Severity icons) may crash or fail to render.",
          "timeline": "This Week"
        }
      ],
      "medium": [
        {
          "issue": {
            "type": "error_handling",
            "severity": "medium",
            "file": "lib/services/autoFix.ts",
            "description": "Fragile JSON parsing using RegExp for AI responses."
          },
          "riskLevel": "medium",
          "urgency": "can-wait",
          "impact": "The 'Auto-Fix' feature will fail intermittently if the AI model adds conversational 'chatter' or markdown blocks outside the JSON.",
          "timeline": "Next Sprint"
        },
        {
          "issue": {
            "type": "performance",
            "severity": "medium",
            "file": "lib/services/repoReader.ts",
            "description": "Sequential recursive API calls for directory reading."
          },
          "riskLevel": "medium",
          "urgency": "can-wait",
          "impact": "Large repositories will take minutes to analyze instead of seconds, potentially hitting Vercel's 10-30s execution limit for API routes.",
          "timeline": "Next Sprint"
        }
      ],
      "low": [
        {
          "issue": {
            "type": "quality",
            "severity": "low",
            "file": "app/api/sessions/route.ts",
            "description": "O(n) session cleanup reads every file on every POST request."
          },
          "riskLevel": "low",
          "urgency": "nice-to-have",
          "impact": "Slight performance degradation as the session history grows. Not an immediate threat but scales poorly.",
          "timeline": "Next Month"
        }
      ],
      "summary": {
        "fixNow": 2,
        "fixSoon": 2,
        "canWait": 2,
        "niceToHave": 1
      },
      "recommendations": [
        "1. Sanitize 'id' in the sessions route using path.basename() or a UUID regex to prevent traversal.",
        "2. Migrate 'activeAgents' to Redis or a database to support serverless persistence.",
        "3. Implement GitHub Personal Access Token (PAT) authentication to increase rate limits to 5,000/hr.",
        "4. Add Zod schema validation for all AI JSON responses to ensure type safety."
      ]
    },
    "metrics": {
      "maintainability": 68,
      "complexity": 52,
      "testability": 65,
      "security": 38,
      "performance": 55,
      "overall": 56,
      "recommendations": [
        "Implement path sanitization for the /api/sessions/[id] routes to prevent directory traversal attacks.",
        "Replace in-memory 'activeAgents' Map with a persistent store (e.g., Redis or a database) to support serverless scaling.",
        "Refactor 'readDirectoryRecursive' to use Promise.all() for concurrent file fetching to prevent timeouts on larger repositories.",
        "Introduce a schema validation library like Zod to validate AI-generated JSON and ensure runtime type safety for CodeIssues.",
        "Add a GitHub Personal Access Token (PAT) to API requests to significantly increase rate limits and prevent service denial.",
        "Centralize AI response parsing logic into a utility to handle various edge cases (markdown fences, multiple blocks) consistently."
      ],
      "trends": {
        "improvement": [
          "Modular service-oriented architecture",
          "Strong TypeScript interface definitions for core domain entities",
          "Clean separation between AI orchestration and UI presentation"
        ],
        "degradation": [
          "Insecure file system interactions in session management",
          "In-memory state management incompatible with cloud-native deployments",
          "Inefficient O(n) file operations during session cleanup"
        ]
      }
    },
    "files": [
      {
        "path": "app/api/analyze/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { readFilesFromUpload, readFilesFromGitHub, filterCodeFiles, countAllFilesFromGitHub } from '@/lib/services/repoReader';\nimport { analyzeCodebase } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const repoUrl = formData.get('repoUrl') as string;\n    const files = formData.getAll('files') as File[];\n\n    let codeFiles, totalRepoFiles = 0;\n\n    if (repoUrl) {\n      totalRepoFiles = await countAllFilesFromGitHub(repoUrl);\n      codeFiles = await readFilesFromGitHub(repoUrl);\n    } else if (files.length > 0) {\n      const formDataObj = new FormData();\n      files.forEach(file => formDataObj.append('file', file));\n      codeFiles = await readFilesFromUpload(formDataObj);\n      totalRepoFiles = files.length;\n    } else {\n      return createErrorResponse('Either repoUrl or files must be provided', 400);\n    }\n\n    const filteredFiles = filterCodeFiles(codeFiles);\n    if (!filteredFiles.length) {\n      return createErrorResponse('No code files found', 400);\n    }\n\n    const analysis = await analyzeCodebase(filteredFiles);\n    analysis.totalRepoFiles = totalRepoFiles;\n    analysis.ignoredFiles = totalRepoFiles - filteredFiles.length;\n\n    return createApiResponse(true, { analysis, files: filteredFiles });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    const errorMessage = error.message || 'Internal server error';\n    const statusCode = errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('RESOURCE_EXHAUSTED') ? 429 : 500;\n    return createErrorResponse(errorMessage, statusCode);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/business-impact/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { analyzeBusinessImpact, analyzeMultipleIssues } from '@/lib/services/businessImpact';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { issue, issues, codebaseContext } = body;\n\n    if (issue) {\n      // Single issue analysis\n      const impact = await analyzeBusinessImpact(issue, codebaseContext);\n      return createApiResponse(true, { impact });\n    } else if (issues && Array.isArray(issues)) {\n      // Multiple issues analysis\n      const impacts = await analyzeMultipleIssues(issues, codebaseContext);\n      return createApiResponse(true, { impacts });\n    } else {\n      return createErrorResponse('Either \"issue\" or \"issues\" array must be provided', 400);\n    }\n  } catch (error: any) {\n    console.error('Business Impact API Error:', error);\n    return createErrorResponse(error.message || 'Failed to analyze business impact', 500);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/code-metrics/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { calculateCodeMetrics } from '@/lib/services/codeMetrics';\nimport { CodeFile, CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody, validateArray } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { files, issues } = body;\n    const filesError = validateArray(files, 'Files');\n    const issuesError = validateArray(issues, 'Issues');\n    if (filesError) return filesError;\n    if (issuesError) return issuesError;\n\n    if (!files || files.length === 0) {\n      return createErrorResponse('No files provided for metrics calculation', 400);\n    }\n\n    const metrics = await calculateCodeMetrics(files as CodeFile[], (issues || []) as CodeIssue[]);\n    return createApiResponse(true, { metrics });\n  } catch (error: any) {\n    console.error('Code Metrics API Error:', error);\n    const errorMessage = error.message || 'Internal server error';\n    \n    // Check if it's a quota error\n    if (errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('RESOURCE_EXHAUSTED')) {\n      return createErrorResponse('API quota exceeded. Please wait or use a different API key.', 429);\n    }\n    \n    return createErrorResponse(errorMessage);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/context-aware-fix/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { generateContextAwareFix } from '@/lib/services/contextAwareFix';\nimport { CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { issue, fileContent } = body;\n    if (!issue || !fileContent) {\n      return createErrorResponse('Issue and fileContent are required', 400);\n    }\n\n    const fix = await generateContextAwareFix(\n      issue as CodeIssue,\n      fileContent,\n      body.codebaseContext || ''\n    );\n    return createApiResponse(true, { fix });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/explain-fix/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { explainFixes } from '@/lib/services/fixExplainer';\nimport { CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody, validateArray } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { issues, files } = body;\n    const issuesError = validateArray(issues, 'Issues');\n    const filesError = validateArray(files, 'Files');\n    if (issuesError) return issuesError;\n    if (filesError) return filesError;\n\n    const explanations = await explainFixes(issues as CodeIssue[], files);\n    return createApiResponse(true, { explanations });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/fix/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { generateFixes } from '@/lib/services/autoFix';\nimport { CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody, validateArray } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { files, issues } = body;\n    const filesError = validateArray(files, 'Files');\n    const issuesError = validateArray(issues, 'Issues');\n    if (filesError) return filesError;\n    if (issuesError) return issuesError;\n\n    const fixes = await generateFixes(files, issues as CodeIssue[]);\n    return createApiResponse(true, { fixes });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/generate-tests/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { readFilesFromGitHub, filterCodeFiles } from '@/lib/services/repoReader';\nimport { generateTests } from '@/lib/services/testGenerator';\nimport { createApiResponse, createErrorResponse, parseJsonBody } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { repoUrl, files, testTypes } = body;\n    let codeFiles = files || [];\n\n    if (repoUrl) {\n      codeFiles = await readFilesFromGitHub(repoUrl);\n    } else if (!codeFiles.length) {\n      return createErrorResponse('Either repoUrl or files must be provided', 400);\n    }\n\n    const filteredFiles = filterCodeFiles(codeFiles);\n    if (!filteredFiles.length) {\n      return createErrorResponse('No code files found', 400);\n    }\n\n    const tests = await generateTests(filteredFiles, testTypes || ['unit', 'integration', 'security']);\n    return createApiResponse(true, { tests });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/marathon/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { createMarathonAgent, MarathonConfig } from '@/lib/services/marathonAgent';\nimport { createApiResponse, createErrorResponse, parseJsonBody } from '@/lib/utils/apiHelper';\n\nconst activeAgents = new Map<string, ReturnType<typeof createMarathonAgent>>();\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { action, taskId, config } = body;\n\n    if (action === 'start') {\n      const marathonConfig: MarathonConfig = {\n        repoUrl: config.repoUrl,\n        testInterval: config.testInterval || 60,\n        autoFix: config.autoFix || false,\n        notifyOnIssue: config.notifyOnIssue || false\n      };\n      const agent = createMarathonAgent(marathonConfig);\n      await agent.start();\n      activeAgents.set(agent.getStatus().id, agent);\n      return createApiResponse(true, { taskId: agent.getStatus().id, status: agent.getStatus() });\n    }\n\n    if (action === 'stop') {\n      const agent = activeAgents.get(taskId);\n      if (!agent) return createErrorResponse('Agent not found', 404);\n      agent.stop();\n      activeAgents.delete(taskId);\n      return createApiResponse(true, { message: 'Marathon agent stopped' });\n    }\n\n    if (action === 'status') {\n      const agent = activeAgents.get(taskId);\n      if (!agent) return createErrorResponse('Agent not found', 404);\n      return createApiResponse(true, { status: agent.getStatus() });\n    }\n\n    return createErrorResponse('Invalid action', 400);\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const taskId = searchParams.get('taskId');\n\n    if (taskId) {\n      const agent = activeAgents.get(taskId);\n      if (!agent) return createErrorResponse('Agent not found', 404);\n      return createApiResponse(true, { status: agent.getStatus() });\n    }\n\n    const agents = Array.from(activeAgents.values()).map(agent => agent.getStatus());\n    return createApiResponse(true, { agents });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/reasoning-chain/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { generateReasoningChain, generateReasoningChains } from '@/lib/services/reasoningChains';\nimport { CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { issue, issues, fileContent, files, codebaseContext } = body;\n\n    if (issue && fileContent) {\n      const chain = await generateReasoningChain(issue as CodeIssue, fileContent, codebaseContext);\n      return createApiResponse(true, { chain });\n    }\n\n    if (issues && files) {\n      const chains = await generateReasoningChains(issues as CodeIssue[], files);\n      return createApiResponse(true, { chains });\n    }\n\n    return createErrorResponse('Issue and fileContent, or issues and files are required', 400);\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/risk-timeline/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { generateRiskTimeline } from '@/lib/services/riskTimeline';\nimport { CodeIssue } from '@/lib/services/codeAnalyzer';\nimport { createApiResponse, createErrorResponse, parseJsonBody, validateArray } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { issues } = body;\n    const issuesError = validateArray(issues, 'Issues');\n    if (issuesError) return issuesError;\n\n    if (!issues || issues.length === 0) {\n      return createErrorResponse('No issues provided for timeline generation', 400);\n    }\n\n    const timeline = await generateRiskTimeline(issues as CodeIssue[], body.codebaseContext);\n    return createApiResponse(true, { timeline });\n  } catch (error: any) {\n    console.error('Risk Timeline API Error:', error);\n    const errorMessage = error.message || 'Internal server error';\n    \n    // Check if it's a quota error\n    if (errorMessage.includes('429') || errorMessage.includes('quota') || errorMessage.includes('RESOURCE_EXHAUSTED')) {\n      return createErrorResponse('API quota exceeded. Please wait or use a different API key.', 429);\n    }\n    \n    return createErrorResponse(errorMessage);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/run-tests/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { runTests } from '@/lib/services/testRunner';\nimport { TestCase } from '@/lib/services/testGenerator';\nimport { createApiResponse, createErrorResponse, parseJsonBody, validateArray } from '@/lib/utils/apiHelper';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await parseJsonBody(request);\n    if (!body) return createErrorResponse('Invalid JSON body', 400);\n\n    const { tests } = body;\n    const testsError = validateArray(tests, 'Tests');\n    if (testsError) return testsError;\n\n    const results = await runTests(tests as TestCase[]);\n    return createApiResponse(true, { results });\n  } catch (error: any) {\n    console.error('API Error:', error);\n    return createErrorResponse(error.message || 'Internal server error');\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/sessions/[id]/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nconst SESSIONS_DIR = path.join(process.cwd(), 'data', 'sessions');\n\n// GET: Get a specific session by ID\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n    const fileName = `${sessionId}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n      return createApiResponse(true, { session });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error getting session:', error);\n    return createErrorResponse(error.message || 'Failed to get session', 500);\n  }\n}\n\n// DELETE: Delete a session by ID\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n    const fileName = `${sessionId}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    try {\n      await fs.unlink(filePath);\n      return createApiResponse(true, { message: 'Session deleted successfully' });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error deleting session:', error);\n    return createErrorResponse(error.message || 'Failed to delete session', 500);\n  }\n}\n\n// PATCH: Update session data (for issueData)\nexport async function PATCH(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const { id } = await params;\n    const filePath = path.join(SESSIONS_DIR, `${id}.json`);\n    const body = await request.json();\n\n    try {\n      // Read existing session\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n\n      // Update session with new data\n      if (body.issueData !== undefined) {\n        if (!session.results.issueData) {\n          session.results.issueData = {};\n        }\n        session.results.issueData = { ...session.results.issueData, ...body.issueData };\n      }\n      \n      // Update timeline if provided\n      if (body.results?.timeline !== undefined) {\n        session.results.timeline = body.results.timeline;\n      }\n      \n      // Update metrics if provided\n      if (body.results?.metrics !== undefined) {\n        session.results.metrics = body.results.metrics;\n      }\n      \n      // Update businessImpactData if provided\n      if (body.businessImpactData !== undefined) {\n        if (!session.results.businessImpactData) {\n          session.results.businessImpactData = {};\n        }\n        session.results.businessImpactData = { ...session.results.businessImpactData, ...body.businessImpactData };\n      }\n      \n      // Full results update (for complete replacement)\n      if (body.results && Object.keys(body.results).length > 0) {\n        session.results = { ...session.results, ...body.results };\n      }\n\n      // Save updated session\n      await fs.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');\n      \n      return createApiResponse(true, { session });\n    } catch (fileError: any) {\n      if (fileError.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw fileError;\n    }\n  } catch (error: any) {\n    console.error('Error updating session:', error);\n    return createErrorResponse(error.message || 'Failed to update session', 500);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/api/sessions/route.ts",
        "content": "import { NextRequest } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nconst SESSIONS_DIR = path.join(process.cwd(), 'data', 'sessions');\n\n// Ensure sessions directory exists\nasync function ensureSessionsDir() {\n  try {\n    await fs.mkdir(SESSIONS_DIR, { recursive: true });\n  } catch (error) {\n    console.error('Failed to create sessions directory:', error);\n  }\n}\n\n// GET: Get all sessions\nexport async function GET() {\n  try {\n    await ensureSessionsDir();\n    \n    const files = await fs.readdir(SESSIONS_DIR);\n    const jsonFiles = files.filter(f => f.endsWith('.json'));\n    \n    console.log(`Found ${jsonFiles.length} session files:`, jsonFiles);\n    \n    const sessions = await Promise.all(\n      jsonFiles.map(async (file) => {\n        try {\n          const filePath = path.join(SESSIONS_DIR, file);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const session = JSON.parse(content);\n          \n          // Ensure session has required fields\n          if (!session.id) {\n            console.warn(`Session file ${file} missing id, using filename`);\n            session.id = file.replace('.json', '');\n          }\n          if (!session.timestamp) {\n            console.warn(`Session file ${file} missing timestamp, using file mtime`);\n            const stats = await fs.stat(filePath);\n            session.timestamp = stats.mtime.getTime();\n          }\n          if (!session.name) {\n            console.warn(`Session file ${file} missing name, using id`);\n            session.name = session.id;\n          }\n          \n          return session;\n        } catch (error) {\n          console.error(`Error reading session file ${file}:`, error);\n          return null;\n        }\n      })\n    );\n    \n    // Filter out null values and sort by timestamp (newest first)\n    const validSessions = sessions\n      .filter(s => s !== null && s.id && s.name)\n      .sort((a, b) => b.timestamp - a.timestamp);\n    \n    console.log(`Returning ${validSessions.length} valid sessions`);\n    \n    return createApiResponse(true, { sessions: validSessions });\n  } catch (error: any) {\n    console.error('Error getting sessions:', error);\n    return createErrorResponse(error.message || 'Failed to get sessions', 500);\n  }\n}\n\n// POST: Save a new session\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureSessionsDir();\n    \n    const body = await request.json();\n    const { name, repoUrl, results, config } = body;\n    \n    if (!name || !results) {\n      return createErrorResponse('Name and results are required', 400);\n    }\n    \n    const session = {\n      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      name,\n      timestamp: Date.now(),\n      repoUrl: repoUrl || undefined,\n      results,\n      config: config || {\n        testTypes: [],\n        duration: 'one-time',\n        autoFix: false\n      }\n    };\n    \n    const fileName = `${session.id}.json`;\n    const filePath = path.join(SESSIONS_DIR, fileName);\n    \n    await fs.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');\n    \n    // Clean up old sessions (keep only last 50)\n    const files = await fs.readdir(SESSIONS_DIR);\n    const jsonFiles = files.filter(f => f.endsWith('.json'));\n    \n    if (jsonFiles.length > 50) {\n      const sessionsWithTime = await Promise.all(\n        jsonFiles.map(async (file) => {\n          try {\n            const filePath = path.join(SESSIONS_DIR, file);\n            const content = await fs.readFile(filePath, 'utf-8');\n            const session = JSON.parse(content);\n            return { file, timestamp: session.timestamp };\n          } catch {\n            return { file, timestamp: 0 };\n          }\n        })\n      );\n      \n      // Sort by timestamp and delete oldest\n      sessionsWithTime.sort((a, b) => a.timestamp - b.timestamp);\n      const toDelete = sessionsWithTime.slice(0, sessionsWithTime.length - 50);\n      \n      for (const { file } of toDelete) {\n        try {\n          await fs.unlink(path.join(SESSIONS_DIR, file));\n        } catch (error) {\n          console.error(`Error deleting old session ${file}:`, error);\n        }\n      }\n    }\n    \n    return createApiResponse(true, { session });\n  } catch (error: any) {\n    console.error('Error saving session:', error);\n    return createErrorResponse(error.message || 'Failed to save session', 500);\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/layout.tsx",
        "content": "import type { Metadata } from \"next\";\nimport { Geist, Geist_Mono } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst geistSans = Geist({\n  variable: \"--font-geist-sans\",\n  subsets: [\"latin\"],\n});\n\nconst geistMono = Geist_Mono({\n  variable: \"--font-geist-mono\",\n  subsets: [\"latin\"],\n});\n\nexport const metadata: Metadata = {\n  title: \"Shels - Gemini 3\",\n  description: \"Autonomous code testing and analysis powered by Google Gemini 3 AI\",\n  icons: {\n    icon: '/icon.png',\n    apple: '/icon.png',\n  },\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\" className=\"dark\">\n      <body\n        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-[#0f0f0f]`}\n      >\n        {children}\n      </body>\n    </html>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "app/page.tsx",
        "content": "'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport Image from 'next/image';\nimport Sidebar from '@/components/Sidebar';\nimport Header from '@/components/Header';\nimport TestConfig from '@/components/TestConfig';\nimport ResultsView from '@/components/ResultsView';\nimport LoadingSpinner from '@/components/LoadingSpinner';\nimport ErrorMessage from '@/components/ErrorMessage';\nimport { useCodeTesting } from '@/hooks/useCodeTesting';\n\nexport default function HomePage() {\n  const [sidebarOpen, setSidebarOpen] = useState(true);\n  const [error, setError] = useState<{ message: string; type?: 'error' | 'warning' | 'info' } | null>(null);\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [showConfig, setShowConfig] = useState(false);\n  const [isMobile, setIsMobile] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement | null>(null);\n\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 768);\n      if (window.innerWidth < 768) {\n        setSidebarOpen(false);\n      }\n    };\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n  const [typingText, setTypingText] = useState('');\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const typingRef = useRef<{ charIndex: number; isDeleting: boolean; timeoutId: NodeJS.Timeout | null }>({\n    charIndex: 0,\n    isDeleting: false,\n    timeoutId: null\n  });\n  \n  const sentences = [\n    \"Meet Shels: your autonomous testing agent\",\n    \"Automate code testing, analysis, and fixes with AI\",\n    \"Save hours of manual testing and debugging\",\n    \"Catch bugs before they reach production\",\n    \"Ship faster with confidence in your code quality\"\n  ];\n\n  useEffect(() => {\n    const currentSentence = sentences[currentSentenceIndex];\n    \n    const type = () => {\n      const { charIndex, isDeleting } = typingRef.current;\n      \n      if (isDeleting) {\n        setTypingText(currentSentence.substring(0, charIndex - 1));\n        typingRef.current.charIndex--;\n      } else {\n        setTypingText(currentSentence.substring(0, charIndex + 1));\n        typingRef.current.charIndex++;\n      }\n\n      if (!isDeleting && typingRef.current.charIndex === currentSentence.length) {\n        typingRef.current.timeoutId = setTimeout(() => {\n          typingRef.current.isDeleting = true;\n          type();\n        }, 2000);\n        return;\n      } else if (isDeleting && typingRef.current.charIndex === 0) {\n        typingRef.current.isDeleting = false;\n        setCurrentSentenceIndex((prev) => (prev + 1) % sentences.length);\n        return;\n      }\n\n      const speed = isDeleting ? 50 : 100;\n      typingRef.current.timeoutId = setTimeout(type, speed);\n    };\n\n    typingRef.current.charIndex = 0;\n    typingRef.current.isDeleting = false;\n    typingRef.current.timeoutId = setTimeout(type, 100);\n    \n    return () => {\n      if (typingRef.current.timeoutId) {\n        clearTimeout(typingRef.current.timeoutId);\n      }\n    };\n  }, [currentSentenceIndex]);\n  const {\n    repoUrl, files, testTypes, duration, autoFix, isAnalyzing, results, progress, marathonTaskId, currentSessionId,\n    setRepoUrl, setFiles, handleTestTypeChange, setDuration, setAutoFix, handleStartTesting,\n    setMarathonTaskId, setErrorCallback, regenerateTimeline, regenerateMetrics, loadSession\n  } = useCodeTesting();\n\n  useEffect(() => {\n    setErrorCallback?.((err: { message: string; type?: 'error' | 'warning' | 'info' }) => {\n      setError(err);\n      setTimeout(() => setError(null), 5000);\n    });\n  }, [setErrorCallback]);\n\n  const handleStopMarathon = async () => {\n    if (!marathonTaskId) return;\n    await fetch('/api/marathon', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ action: 'stop', taskId: marathonTaskId })\n    });\n    setMarathonTaskId(null);\n  };\n\n  const handleLoadSession = (session: any) => {\n    loadSession(session);\n  };\n\n  return (\n    <div className=\"flex h-screen bg-[#0f0f0f] text-white overflow-hidden\">\n      <Sidebar \n        isOpen={sidebarOpen} \n        onToggle={() => setSidebarOpen(!sidebarOpen)}\n        onLoadSession={handleLoadSession}\n        isMobile={isMobile}\n      />\n      \n      {isMobile && sidebarOpen && (\n        <div \n          className=\"fixed inset-0 bg-black bg-opacity-50 z-10 md:hidden\"\n          onClick={() => setSidebarOpen(false)}\n        />\n      )}\n      \n      <div className={`flex-1 flex flex-col transition-all duration-300 ${\n        isMobile \n          ? (sidebarOpen ? 'ml-0' : 'ml-0') \n          : (sidebarOpen ? 'ml-64' : 'ml-16')\n      }`}>\n        <Header sidebarOpen={sidebarOpen} isMobile={isMobile} onToggleSidebar={() => setSidebarOpen(!sidebarOpen)} />\n        \n        <main className={`flex-1 overflow-y-auto pt-16 ${isMobile ? 'px-4 py-4' : 'px-8 py-8'}`}>\n          <div className=\"max-w-4xl mx-auto\">\n            {/* Hero Section */}\n            <div className={`${isMobile ? 'mb-6 mt-4' : 'mb-12 mt-8'}`}>\n              <h1 className={`${isMobile ? 'text-xl' : 'text-3xl'} font-bold ${isMobile ? 'mb-2' : 'mb-3'} text-white flex items-center gap-2 min-h-[3rem] flex-wrap`}>\n                <Image src=\"/icon.png\" alt=\"Shels\" width={40} height={40} className={`${isMobile ? 'w-8 h-8' : 'w-10 h-10'} flex-shrink-0`} />\n                <span className=\"flex-1 text-wrap break-words\">\n                  {typingText}\n                  <span className=\"animate-pulse\">|</span>\n                </span>\n              </h1>\n              <p className={`${isMobile ? 'text-sm' : 'text-base'} text-gray-400 ${isMobile ? 'mb-4' : 'mb-8'}`}>\n                Shels will analyze, test, and fix your code automatically. Focus on what you care about while the agent works!\n              </p>\n\n              {/* Main Input with Dropdown */}\n              <div className=\"bg-[#171717] border border-[#2f0012] rounded-lg mb-8\">\n                <div className={`${isMobile ? 'p-2' : 'p-4'} flex items-center gap-2 flex-wrap`}>\n                  <div className={`flex items-center ${isMobile ? 'gap-1' : 'gap-2'}`}>\n                    <button\n                      onClick={() => setIsExpanded(!isExpanded)}\n                      className={`${isMobile ? 'p-1.5' : 'p-2'} text-gray-400 hover:text-white hover:bg-[#1f1f1f] rounded-lg transition-colors`}\n                      title=\"Settings\"\n                    >\n                      <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                      </svg>\n                    </button>\n                    <button\n                      onClick={() => fileInputRef.current?.click()}\n                      className={`${isMobile ? 'p-1.5' : 'p-2'} text-gray-400 hover:text-white hover:bg-[#1f1f1f] rounded-lg transition-colors`}\n                      title=\"Upload Files\"\n                      type=\"button\"\n                    >\n                      <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n                      </svg>\n                    </button>\n                    <input\n                      ref={fileInputRef}\n                      type=\"file\"\n                      multiple\n                      onChange={(e) => {\n                        if (e.target.files) {\n                          setFiles(Array.from(e.target.files));\n                          setRepoUrl('');\n                        }\n                      }}\n                      className=\"hidden\"\n                      {...({ webkitdirectory: '' } as any)}\n                    />\n                    <button\n                      onClick={() => window.open('https://github.com', '_blank')}\n                      className={`${isMobile ? 'p-1.5' : 'p-2'} text-gray-400 hover:text-white hover:bg-[#1f1f1f] rounded-lg transition-colors`}\n                      title=\"GitHub\"\n                    >\n                      <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path d=\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"/>\n                      </svg>\n                    </button>\n                  </div>\n                  <input\n                    type=\"text\"\n                    value={repoUrl}\n                    onChange={(e) => setRepoUrl(e.target.value)}\n                    placeholder={isMobile ? \"GitHub repo URL\" : \"https://github.com/user/repo\"}\n                    className={`flex-1 min-w-0 bg-transparent text-white placeholder-gray-500 focus:outline-none ${isMobile ? 'text-sm' : 'text-lg'}`}\n                    disabled={isAnalyzing}\n                  />\n                  <button\n                    onClick={handleStartTesting}\n                    disabled={isAnalyzing || (!repoUrl && files.length === 0)}\n                    className={`${isMobile ? 'p-1.5' : 'p-2'} bg-gray-700 hover:bg-gray-600 text-white rounded-lg disabled:bg-gray-800 disabled:cursor-not-allowed transition-colors flex-shrink-0`}\n                    title=\"Start Testing\"\n                  >\n                    {isAnalyzing ? (\n                      <svg className={`${isMobile ? 'h-4 w-4' : 'h-5 w-5'} animate-spin`} fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      ) : (\n                        <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 7l5 5m0 0l-5 5m5-5H6\" />\n                        </svg>\n                      )}\n                  </button>\n                </div>\n                \n                {/* Expanded Configuration */}\n                {isExpanded && (\n                  <div className=\"border-t border-[#2f0012] p-4 space-y-4\">\n                    {files.length > 0 && (\n                      <div className=\"text-sm text-gray-400\">\n                        {files.length} files selected\n                      </div>\n                    )}\n                    <div className=\"space-y-4\">\n                      <div>\n                        <label className=\"block text-sm font-medium mb-2 text-gray-400\">Test Types</label>\n                        <div className=\"grid grid-cols-2 gap-2\">\n                          {(['unit', 'integration', 'security', 'performance'] as const).map(type => (\n                            <label key={type} className=\"flex items-center text-gray-300 cursor-pointer hover:text-white text-sm\">\n                              <input\n                                type=\"checkbox\"\n                                checked={testTypes.includes(type)}\n                                onChange={() => handleTestTypeChange(type)}\n                                className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] rounded focus:ring-gray-700\"\n                              />\n                              {type.charAt(0).toUpperCase() + type.slice(1)} Tests\n                            </label>\n                          ))}\n                        </div>\n                      </div>\n                      <div>\n                        <label className=\"block text-sm font-medium mb-2 text-gray-400\">Duration</label>\n                        <div className=\"space-y-2\">\n                          <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white text-sm\">\n                            <input\n                              type=\"radio\"\n                              name=\"duration\"\n                              value=\"one-time\"\n                              checked={duration === 'one-time'}\n                              onChange={() => setDuration('one-time')}\n                              className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] focus:ring-gray-700\"\n                            />\n                            One-time test (run once)\n                          </label>\n                          <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white text-sm\">\n                            <input\n                              type=\"radio\"\n                              name=\"duration\"\n                              value=\"continuous\"\n                              checked={duration === 'continuous'}\n                              onChange={() => setDuration('continuous')}\n                              className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] focus:ring-gray-700\"\n                            />\n                            Continuous monitoring (24/7)\n                          </label>\n                        </div>\n                      </div>\n                      <div>\n                        <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white text-sm\">\n                          <input\n                            type=\"checkbox\"\n                            checked={autoFix}\n                            onChange={(e) => setAutoFix(e.target.checked)}\n                            className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] rounded focus:ring-gray-700\"\n                          />\n                          Enable automatic fixes\n                        </label>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              </div>\n            </div>\n\n            {/* Try Examples Section */}\n            {!isAnalyzing && !results && (\n              <div className={`${isMobile ? 'mb-4' : 'mb-8'}`}>\n                <div className={`flex items-center gap-2 ${isMobile ? 'mb-2' : 'mb-4'}`}>\n                  <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'} text-gray-500`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2\" />\n                  </svg>\n                  <h3 className={`${isMobile ? 'text-base' : 'text-lg'} font-semibold text-white`}>Try Shels out</h3>\n                </div>\n                <div className={`flex ${isMobile ? 'flex-wrap gap-2' : 'gap-3'}`}>\n                  {['React App', 'Node.js API', 'TypeScript Project'].map((example) => (\n                    <button\n                      key={example}\n                      className={`bg-[#171717] border border-[#2f0012] hover:border-[#4a0020] text-white ${isMobile ? 'px-3 py-1.5 text-sm' : 'px-4 py-2'} rounded-lg transition-colors`}\n                    >\n                      {example}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Integrate Section */}\n            {!isAnalyzing && !results && (\n              <div className={`${isMobile ? 'mb-4' : 'mb-8'}`}>\n                <div className={`flex items-center gap-2 ${isMobile ? 'mb-2' : 'mb-4'}`}>\n                  <svg className={`${isMobile ? 'w-4 h-4' : 'w-5 h-5'} text-gray-500`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 7l5 5m0 0l-5 5m5-5H6\" />\n                  </svg>\n                  <h3 className={`${isMobile ? 'text-base' : 'text-lg'} font-semibold text-white`}>Integrate Shels</h3>\n                </div>\n                <div className={`flex ${isMobile ? 'flex-wrap gap-2' : 'gap-3'}`}>\n                  <button className={`bg-[#171717] border border-[#2f0012] hover:border-[#4a0020] text-white ${isMobile ? 'px-3 py-1.5 text-sm' : 'px-4 py-2'} rounded-lg transition-colors flex items-center gap-2`}>\n                    <svg className={`${isMobile ? 'w-3 h-3' : 'w-4 h-4'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                    </svg>\n                    {isMobile ? 'Render' : 'Configure Render'}\n                  </button>\n                  <button className={`bg-[#171717] border border-[#2f0012] hover:border-[#4a0020] text-white ${isMobile ? 'px-3 py-1.5 text-sm' : 'px-4 py-2'} rounded-lg transition-colors flex items-center gap-2`}>\n                    <svg className={`${isMobile ? 'w-3 h-3' : 'w-4 h-4'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n                    </svg>\n                    {isMobile ? 'CLI' : 'Download CLI'}\n                  </button>\n                  <button className={`bg-[#171717] border border-[#2f0012] hover:border-[#4a0020] text-white ${isMobile ? 'px-3 py-1.5 text-sm' : 'px-4 py-2'} rounded-lg transition-colors flex items-center gap-2`}>\n                    <span className={`${isMobile ? 'text-xs' : 'text-sm'}`}>&lt; &gt;</span>\n                    {isMobile ? 'API' : 'Try API'}\n                  </button>\n                </div>\n              </div>\n            )}\n\n            {/* Loading */}\n            {isAnalyzing && <LoadingSpinner progress={progress} />}\n\n            {/* Results */}\n            {results && (\n              <ResultsView\n                results={results}\n                marathonTaskId={marathonTaskId}\n                sessionId={currentSessionId}\n                onError={(message, type) => setError({ message, type })}\n                onStopMarathon={handleStopMarathon}\n                onRegenerateTimeline={regenerateTimeline}\n                onRegenerateMetrics={regenerateMetrics}\n              />\n            )}\n\n            {/* Info Text */}\n            {!isAnalyzing && !results && (\n              <div className=\"mt-8 p-4 bg-yellow-900/10 border border-yellow-800/30 rounded-lg\">\n                <p className=\"text-sm text-yellow-200\">\n                  Shels is powerful and can execute on any inputs and repositories received. \n                  For best results, read the <a href=\"#\" className=\"underline\">usage guide</a>.\n          </p>\n        </div>\n            )}\n\n            {/* Footer */}\n            <div className={`${isMobile ? 'mt-6 pt-4' : 'mt-12 pt-8'} border-t border-[#2f0012] flex ${isMobile ? 'flex-wrap gap-3' : 'gap-6'} ${isMobile ? 'text-xs' : 'text-sm'} text-gray-500`}>\n              <a href=\"#\" className=\"hover:text-gray-300 transition-colors\">Terms</a>\n              <a href=\"#\" className=\"hover:text-gray-300 transition-colors\">Open source licenses</a>\n              <a href=\"#\" className=\"hover:text-gray-300 transition-colors\">Use code with caution</a>\n            </div>\n        </div>\n      </main>\n      </div>\n\n      {error && (\n        <ErrorMessage\n          message={error.message}\n          type={error.type || 'error'}\n          onClose={() => setError(null)}\n        />\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/BusinessImpactView.tsx",
        "content": "'use client';\n\nimport { useState, useEffect } from 'react';\nimport type { BusinessImpactViewProps, BusinessImpactData, CodeIssue } from '@/lib/types';\n\nexport default function BusinessImpactView({ results, sessionId, onError }: BusinessImpactViewProps) {\n  const [businessImpacts, setBusinessImpacts] = useState<Map<string, BusinessImpactData>>(new Map());\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    loadAllBusinessImpacts();\n  }, [results]);\n\n  const loadAllBusinessImpacts = async () => {\n    if (!results?.analysis?.issues || results.analysis.issues.length === 0) {\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    const impacts = new Map<string, BusinessImpactData>();\n\n    // Load from session if available\n    if (results.businessImpactData) {\n      Object.entries(results.businessImpactData).forEach(([key, value]: [string, BusinessImpactData]) => {\n        impacts.set(key, value);\n      });\n    }\n\n    // Load missing impacts from API\n    const missingIssues = results.analysis.issues.filter((issue: CodeIssue) => {\n      const key = getIssueKey(issue);\n      return !impacts.has(key);\n    });\n\n    if (missingIssues.length > 0) {\n      try {\n        const promises = missingIssues.map(async (issue: any) => {\n          try {\n            const response = await fetch('/api/business-impact', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ issue })\n            });\n            const data = await response.json();\n            if (data.success && data.impact) {\n              return { key: getIssueKey(issue), impact: data.impact };\n            }\n          } catch (error) {\n            console.error(`Failed to load business impact for ${issue.file}:`, error);\n          }\n          return null;\n        });\n\n        const loadedImpacts = await Promise.all(promises);\n        const newImpacts: Record<string, BusinessImpactData> = {};\n        \n        loadedImpacts.forEach(result => {\n          if (result) {\n            impacts.set(result.key, result.impact);\n            newImpacts[result.key] = result.impact;\n          }\n        });\n        \n        // Save new impacts to session\n        if (sessionId && Object.keys(newImpacts).length > 0) {\n          try {\n            await fetch(`/api/sessions/${sessionId}`, {\n              method: 'PATCH',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                businessImpactData: newImpacts\n              })\n            });\n          } catch (error) {\n            console.error('Failed to save business impacts to session:', error);\n          }\n        }\n      } catch (error) {\n        console.error('Failed to load business impacts:', error);\n      }\n    }\n\n    setBusinessImpacts(impacts);\n    setLoading(false);\n  };\n\n  const getIssueKey = (issue: CodeIssue): string => {\n    return `${issue.file}-${issue.type}-${issue.severity}-${issue.description.substring(0, 50)}`;\n  };\n\n  if (loading) {\n    return (\n      <div className=\"mt-4\">\n        <h3 className=\"text-xl font-semibold mb-4 text-white\">Business Impact Analysis</h3>\n        <div className=\"flex items-center justify-center py-8\">\n          <svg className=\"animate-spin h-8 w-8 text-gray-400\" fill=\"none\" viewBox=\"0 0 24 24\">\n            <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n            <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n          </svg>\n          <span className=\"ml-3 text-gray-400\">Loading business impact analysis...</span>\n        </div>\n      </div>\n    );\n  }\n\n  if (businessImpacts.size === 0) {\n    return (\n      <div className=\"mt-4\">\n        <h3 className=\"text-xl font-semibold mb-4 text-white\">Business Impact Analysis</h3>\n        <div className=\"bg-yellow-900/20 border border-[#2f0012] rounded-lg p-4\">\n          <p className=\"text-yellow-200\"> No business impact data available.</p>\n          <p className=\"text-sm text-gray-400 mt-2\">\n            Business impact analysis will be generated automatically when issues are loaded.\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  // Calculate totals and statistics\n  const issues = results.analysis.issues || [];\n  const impactsArray = Array.from(businessImpacts.entries())\n    .map(([key, impact]) => {\n      const issue = issues.find((i: CodeIssue) => getIssueKey(i) === key);\n      return { issue, impact, key };\n    })\n    .filter(item => item.issue && item.impact)\n    .sort((a, b) => (b.impact.impactScore || 0) - (a.impact.impactScore || 0));\n\n  const totalImpactScore = impactsArray.reduce((sum, item) => sum + (item.impact.impactScore || 0), 0);\n  const averageImpactScore = impactsArray.length > 0 ? Math.round(totalImpactScore / impactsArray.length) : 0;\n\n  const criticalCount = impactsArray.filter(item => item.impact.priority === 'critical').length;\n  const highCount = impactsArray.filter(item => item.impact.priority === 'high').length;\n  const mediumCount = impactsArray.filter(item => item.impact.priority === 'medium').length;\n  const lowCount = impactsArray.filter(item => item.impact.priority === 'low').length;\n\n  return (\n    <div className=\"mt-4\">\n      <h3 className=\"text-xl font-semibold mb-4 text-white\">Business Impact Analysis</h3>\n      \n      {/* Summary Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4 mb-6\">\n        <div className=\"bg-red-900/20 border border-red-800/30 p-4 rounded-lg\">\n          <p className=\"text-sm text-gray-400 mb-1\">Average Impact Score</p>\n          <p className=\"text-2xl font-bold text-red-400\">{averageImpactScore}/100</p>\n        </div>\n        <div className=\"bg-orange-900/20 border border-orange-800/30 p-4 rounded-lg\">\n          <p className=\"text-sm text-gray-400 mb-1\">Critical Issues</p>\n          <p className=\"text-2xl font-bold text-orange-400\">{criticalCount}</p>\n        </div>\n        <div className=\"bg-yellow-900/20 border border-yellow-800/30 p-4 rounded-lg\">\n          <p className=\"text-sm text-gray-400 mb-1\">High Priority</p>\n          <p className=\"text-2xl font-bold text-yellow-400\">{highCount}</p>\n        </div>\n        <div className=\"bg-blue-900/20 border border-blue-800/30 p-4 rounded-lg\">\n          <p className=\"text-sm text-gray-400 mb-1\">Total Issues</p>\n          <p className=\"text-2xl font-bold text-blue-400\">{impactsArray.length}</p>\n        </div>\n      </div>\n\n      {/* Priority Distribution */}\n      <div className=\"mb-6 bg-[#1f1f1f] p-4 rounded-lg border border-[#2f0012]\">\n        <h4 className=\"font-semibold text-white mb-3\">Priority Distribution</h4>\n        <div className=\"grid grid-cols-4 gap-4\">\n          <div className=\"text-center\">\n            <p className=\"text-2xl font-bold text-red-400\">{criticalCount}</p>\n            <p className=\"text-xs text-gray-400\">Critical</p>\n          </div>\n          <div className=\"text-center\">\n            <p className=\"text-2xl font-bold text-orange-400\">{highCount}</p>\n            <p className=\"text-xs text-gray-400\">High</p>\n          </div>\n          <div className=\"text-center\">\n            <p className=\"text-2xl font-bold text-yellow-400\">{mediumCount}</p>\n            <p className=\"text-xs text-gray-400\">Medium</p>\n          </div>\n          <div className=\"text-center\">\n            <p className=\"text-2xl font-bold text-gray-400\">{lowCount}</p>\n            <p className=\"text-xs text-gray-400\">Low</p>\n          </div>\n        </div>\n      </div>\n\n      {/* Issues Sorted by Impact */}\n      <div className=\"mb-6\">\n        <h4 className=\"font-semibold text-white mb-3\">Issues Ranked by Business Impact</h4>\n        <div className=\"space-y-3\">\n          {impactsArray.map((item, index) => {\n            const { issue, impact } = item;\n            if (!issue) return null;\n            \n            const impactScore = impact.impactScore || 0;\n            const getImpactColor = (score: number) => {\n              if (score >= 75) return 'text-red-400';\n              if (score >= 50) return 'text-yellow-400';\n              return 'text-green-400';\n            };\n\n            return (\n              <div\n                key={index}\n                className=\"bg-[#1f1f1f] border border-[#2f0012] rounded-lg p-4 hover:bg-[#2a2a2a] transition-colors\"\n              >\n                <div className=\"flex items-start justify-between mb-2\">\n                  <div className=\"flex-1\">\n                    <div className=\"flex items-center gap-3 mb-1\">\n                      <span className=\"text-sm font-semibold text-gray-400\">#{index + 1}</span>\n                      <span className=\"font-semibold text-white\">\n                        {issue.type} - {issue.severity}\n                      </span>\n                      <span className={`text-lg font-bold ${getImpactColor(impactScore)}`}>\n                        {impactScore}/100\n                      </span>\n                      <span className={`text-xs px-2 py-1 rounded ${\n                        impact.priority === 'critical' ? 'bg-red-900/30 text-red-300' :\n                        impact.priority === 'high' ? 'bg-orange-900/30 text-orange-300' :\n                        impact.priority === 'medium' ? 'bg-yellow-900/30 text-yellow-300' :\n                        'bg-gray-800 text-gray-300'\n                      }`}>\n                        {impact.priority}\n                      </span>\n                    </div>\n                    <p className=\"text-sm text-gray-400\">{issue.file}</p>\n                    <p className=\"text-sm text-gray-300 mt-1\">{issue.description}</p>\n                  </div>\n                </div>\n\n                {/* Impact Details */}\n                <div className=\"mt-3 p-3 bg-blue-900/10 border border-blue-800/20 rounded-lg\">\n                  <p className=\"text-xs text-blue-300 mb-2\">{impact.explanation}</p>\n                  \n                  {impact.estimatedCost && (\n                    <div className=\"mt-2 flex flex-wrap gap-2 text-xs\">\n                      {impact.estimatedCost.revenue && (\n                        <span className=\"text-red-300\"> {impact.estimatedCost.revenue}</span>\n                      )}\n                      {impact.estimatedCost.users && (\n                        <span className=\"text-yellow-300\"> {impact.estimatedCost.users}</span>\n                      )}\n                      {impact.estimatedCost.time && (\n                        <span className=\"text-green-300\"> {impact.estimatedCost.time}</span>\n                      )}\n                      {impact.estimatedCost.reputation && (\n                        <span className=\"text-purple-300\"> {impact.estimatedCost.reputation}</span>\n                      )}\n                    </div>\n                  )}\n\n                  {impact.realWorldExample && (\n                    <p className=\"text-xs text-blue-200 mt-2 italic\">\n                       <strong>Example:</strong> {impact.realWorldExample}\n                    </p>\n                  )}\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n\n      {/* Total Estimated Cost Summary */}\n      <div className=\"bg-[#1f1f1f] p-4 rounded-lg border border-[#2f0012]\">\n        <h4 className=\"font-semibold text-white mb-3\"> Total Estimated Business Impact</h4>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 text-sm\">\n          <div>\n            <p className=\"text-gray-400 mb-2\">Revenue Impact:</p>\n            <p className=\"text-white\">\n              {impactsArray.filter(item => item.impact.estimatedCost?.revenue).length} issues affecting revenue\n            </p>\n          </div>\n          <div>\n            <p className=\"text-gray-400 mb-2\">User Impact:</p>\n            <p className=\"text-white\">\n              {impactsArray.filter(item => item.impact.estimatedCost?.users).length} issues affecting users\n            </p>\n          </div>\n          <div>\n            <p className=\"text-gray-400 mb-2\">Time Impact:</p>\n            <p className=\"text-white\">\n              {impactsArray.filter(item => item.impact.estimatedCost?.time).length} issues requiring time investment\n            </p>\n          </div>\n          <div>\n            <p className=\"text-gray-400 mb-2\">Reputation Impact:</p>\n            <p className=\"text-white\">\n              {impactsArray.filter(item => item.impact.estimatedCost?.reputation).length} issues affecting reputation\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/CodeMetricsView.tsx",
        "content": "'use client';\n\nimport { useState } from 'react';\nimport type { CodeMetricsViewProps, CodeMetrics } from '@/lib/types';\n\nexport default function CodeMetricsView({ results, onRegenerate }: CodeMetricsViewProps) {\n  const [isRegenerating, setIsRegenerating] = useState(false);\n  const metrics = results?.metrics;\n  \n  const handleRegenerate = async () => {\n    if (!onRegenerate) return;\n    setIsRegenerating(true);\n    try {\n      await onRegenerate();\n    } catch (error) {\n      // Error handled by onRegenerate\n    } finally {\n      setIsRegenerating(false);\n    }\n  };\n  \n  if (!metrics) {\n    const hasFiles = results?.files?.length > 0 || results?.analysis?.totalFiles > 0;\n    return (\n      <div className=\"mt-4\">\n        <h3 className=\"text-xl font-semibold mb-4 text-white\">Code Metrics</h3>\n      <div className=\"bg-yellow-900/20 border border-[#2f0012] rounded-lg p-4\">\n        <p className=\"text-yellow-200 mb-2\"> No metrics data available.</p>\n        <div className=\"text-sm text-gray-400 mb-4\">\n          {hasFiles ? (\n            <>\n              <p className=\"mb-2\">Files were analyzed but metrics calculation failed. This may happen if:</p>\n              <ul className=\"list-disc list-inside mt-2 space-y-1\">\n                <li>API quota was exceeded (check console for details)</li>\n                <li>An error occurred during calculation</li>\n              </ul>\n            </>\n          ) : (\n            <p>No files were analyzed, so no metrics can be calculated.</p>\n          )}\n          <p className=\"mt-2\">Please check the browser console for details.</p>\n        </div>\n          {hasFiles && onRegenerate && (\n            <button\n              onClick={handleRegenerate}\n              disabled={isRegenerating}\n              className=\"bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg text-sm font-medium disabled:bg-gray-800 disabled:cursor-not-allowed transition-colors\"\n            >\n              {isRegenerating ? 'Regenerating...' : 'Regenerate Metrics'}\n            </button>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"mt-4\">\n      <h3 className=\"text-xl font-semibold mb-4 text-white\">Code Metrics</h3>\n      \n      <IndividualMetrics metrics={metrics} />\n      \n      {/* Show recommendations if available */}\n      {(metrics.testability?.recommendations && metrics.testability.recommendations.length > 0) && (\n        <RecommendationsSection recommendations={metrics.testability.recommendations} />\n      )}\n      \n      {/* Show maintainability factors if available */}\n      {(metrics.maintainability?.factors && metrics.maintainability.factors.length > 0) && (\n        <MaintainabilityFactors factors={metrics.maintainability.factors} />\n      )}\n      \n      {/* Show technical debt if available */}\n      {metrics.technicalDebt && (\n        <TechnicalDebtSection technicalDebt={metrics.technicalDebt} />\n      )}\n      \n      {/* Show overall score and recommendations if available (old format) */}\n      {(metrics as any).overall !== undefined && (\n        <OverallScore score={(metrics as any).overall} />\n      )}\n      \n      {(metrics as any).recommendations && Array.isArray((metrics as any).recommendations) && (metrics as any).recommendations.length > 0 && (\n        <RecommendationsSection recommendations={(metrics as any).recommendations} />\n      )}\n      \n      {(metrics as any).trends && (\n        <TrendsSection trends={(metrics as any).trends} />\n      )}\n    </div>\n  );\n}\n\nfunction OverallScore({ score }: { score: number }) {\n  const color = score >= 80 ? 'green' : score >= 60 ? 'yellow' : 'red';\n  const colorClass = score >= 80 ? 'bg-green-600' : score >= 60 ? 'bg-yellow-600' : 'bg-red-600';\n  \n  return (\n    <div className=\"mb-6\">\n      <div className=\"flex justify-between mb-2\">\n        <span className=\"text-white font-semibold\">Overall Score</span>\n        <span className=\"text-white font-bold text-2xl\">{score}/100</span>\n      </div>\n      <div className=\"w-full bg-gray-800 rounded-full h-4\">\n        <div \n          className={`h-4 rounded-full ${colorClass}`}\n          style={{ width: `${Math.min(100, Math.max(0, score))}%` }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\nfunction IndividualMetrics({ metrics }: { metrics: CodeMetrics }) {\n  // Handle both old format (simple numbers) and new format (objects)\n  const maintainabilityScore = typeof metrics.maintainability === 'number' \n    ? metrics.maintainability \n    : metrics.maintainability?.score || 0;\n  const testabilityScore = typeof metrics.testability === 'number'\n    ? metrics.testability\n    : metrics.testability?.score || 0;\n  const complexityValue = typeof metrics.complexity === 'number'\n    ? metrics.complexity\n    : metrics.complexity?.average || 0;\n  const complexityMax = typeof metrics.complexity === 'object' ? metrics.complexity?.max : undefined;\n  const complexityDist = typeof metrics.complexity === 'object' ? metrics.complexity?.distribution : undefined;\n\n  const metricItems = [\n    { \n      label: 'Maintainability', \n      value: maintainabilityScore, \n      color: maintainabilityScore >= 70 ? 'green' : maintainabilityScore >= 50 ? 'yellow' : 'red',\n      description: 'How easy is it to maintain and modify the code?'\n    },\n    { \n      label: 'Testability', \n      value: testabilityScore, \n      color: testabilityScore >= 70 ? 'green' : testabilityScore >= 50 ? 'yellow' : 'red',\n      description: 'How easy is it to test the code?'\n    },\n    { \n      label: 'Complexity (Avg)', \n      value: complexityValue, \n      color: complexityValue <= 30 ? 'green' : complexityValue <= 60 ? 'yellow' : 'red',\n      description: 'Average cyclomatic complexity (lower is better)',\n      isInverted: true,\n      showExtra: complexityMax !== undefined\n    }\n  ].filter(item => item.value !== undefined);\n\n  if (metricItems.length === 0) return null;\n\n  const colorMap: Record<string, string> = {\n    blue: 'bg-blue-600',\n    red: 'bg-red-600',\n    green: 'bg-green-600',\n    yellow: 'bg-yellow-600',\n    purple: 'bg-purple-600',\n    orange: 'bg-orange-600'\n  };\n\n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 mb-6\">\n      {metricItems.map(item => {\n        const displayValue = item.isInverted ? 100 - item.value : item.value;\n        const percentage = Math.min(100, Math.max(0, displayValue));\n        \n        return (\n          <div key={item.label} className=\"bg-[#1f1f1f] border border-[#2f0012] rounded-lg p-4\">\n            <p className=\"text-sm text-gray-300 mb-1 font-semibold\">{item.label}</p>\n            <p className=\"text-xs text-gray-500 mb-3\">{item.description}</p>\n            <div className=\"w-full bg-gray-800 rounded-full h-3 mb-2\">\n              <div \n                className={`${colorMap[item.color] || 'bg-gray-600'} h-3 rounded-full transition-all`}\n                style={{ width: `${percentage}%` }}\n              ></div>\n            </div>\n            <div className=\"flex justify-between items-center\">\n              <p className=\"text-xs text-gray-400\">Score</p>\n              <p className={`text-sm font-bold ${\n                item.color === 'green' ? 'text-green-400' :\n                item.color === 'yellow' ? 'text-yellow-400' :\n                'text-red-400'\n              }`}>\n                {item.value.toFixed(1)}{item.isInverted ? '' : '%'}\n              </p>\n            </div>\n            {item.isInverted && item.showExtra && complexityMax !== undefined && complexityDist && (\n              <p className=\"text-xs text-gray-500 mt-1\">\n                Max: {complexityMax} | Distribution: {Object.keys(complexityDist).length} levels\n              </p>\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction RecommendationsSection({ recommendations }: { recommendations: string[] }) {\n  return (\n    <div className=\"mb-4 bg-blue-900/20 p-4 rounded-lg border border-[#2f0012]\">\n      <h4 className=\"font-semibold text-blue-300 mb-3\"> Testability Recommendations</h4>\n      <ul className=\"list-disc list-inside space-y-2\">\n        {recommendations.map((rec: string, index: number) => (\n          <li key={index} className=\"text-sm text-gray-300\">{rec}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction MaintainabilityFactors({ factors }: { factors: string[] }) {\n  return (\n    <div className=\"mb-4 bg-green-900/20 p-4 rounded-lg border border-[#2f0012]\">\n      <h4 className=\"font-semibold text-green-300 mb-3\"> Maintainability Factors</h4>\n      <ul className=\"list-disc list-inside space-y-2\">\n        {factors.map((factor: string, index: number) => (\n          <li key={index} className=\"text-sm text-gray-300\">{factor}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction TechnicalDebtSection({ technicalDebt }: { technicalDebt: { hours: number; cost: number; breakdown: Array<{ type: string; hours: number }> } }) {\n  return (\n    <div className=\"mb-4 bg-red-900/20 p-4 rounded-lg border border-[#2f0012]\">\n      <h4 className=\"font-semibold text-red-300 mb-3\"> Technical Debt</h4>\n      <div className=\"grid grid-cols-2 gap-4 mb-4\">\n        <div>\n          <p className=\"text-xs text-gray-400 mb-1\">Estimated Hours</p>\n          <p className=\"text-xl font-bold text-red-400\">{technicalDebt.hours.toFixed(1)}h</p>\n        </div>\n        <div>\n          <p className=\"text-xs text-gray-400 mb-1\">Estimated Cost</p>\n          <p className=\"text-xl font-bold text-red-400\">${technicalDebt.cost.toLocaleString()}</p>\n        </div>\n      </div>\n      {technicalDebt.breakdown && technicalDebt.breakdown.length > 0 && (\n        <div>\n          <p className=\"text-sm text-gray-400 mb-2\">Breakdown by Type:</p>\n          <ul className=\"list-disc list-inside space-y-1\">\n            {technicalDebt.breakdown.map((item, index) => (\n              <li key={index} className=\"text-sm text-gray-300\">\n                {item.type}: {item.hours.toFixed(1)}h\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction TrendsSection({ trends }: { trends: any }) {\n  return (\n    <div className=\"grid grid-cols-2 gap-4\">\n      {trends.improvement?.length > 0 && (\n        <div className=\"bg-green-900/20 p-4 rounded-lg border border-[#2f0012]\">\n          <h4 className=\"font-semibold text-green-400 mb-2\"> Improvements</h4>\n          <ul className=\"list-disc list-inside space-y-1\">\n            {trends.improvement.map((item: string, index: number) => (\n              <li key={index} className=\"text-sm text-gray-300\">{item}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n      {trends.degradation?.length > 0 && (\n        <div className=\"bg-red-900/20 p-4 rounded-lg border border-[#2f0012]\">\n          <h4 className=\"font-semibold text-red-400 mb-2\"> Degradations</h4>\n          <ul className=\"list-disc list-inside space-y-1\">\n            {trends.degradation.map((item: string, index: number) => (\n              <li key={index} className=\"text-sm text-gray-300\">{item}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ErrorMessage.tsx",
        "content": "'use client';\n\ninterface ErrorMessageProps {\n  message: string;\n  onClose: () => void;\n  type?: 'error' | 'warning' | 'info';\n}\n\nexport default function ErrorMessage({ message, onClose, type = 'error' }: ErrorMessageProps) {\n  const bgColor = type === 'error' ? 'bg-red-900/20 border-[#2f0012]' : \n                   type === 'warning' ? 'bg-yellow-900/20 border-[#2f0012]' : \n                   'bg-blue-900/20 border-[#2f0012]';\n  \n  const textColor = type === 'error' ? 'text-red-300' : \n                    type === 'warning' ? 'text-yellow-300' : \n                    'text-blue-300';\n  \n  const icon = type === 'error' ? '' : type === 'warning' ? '' : '';\n\n  return (\n    <div className={`fixed top-4 right-4 ${bgColor} border-2 rounded-lg p-4 shadow-lg z-50 max-w-md`}>\n      <div className=\"flex items-start justify-between\">\n        <div className=\"flex items-start\">\n          <span className=\"text-xl mr-2\">{icon}</span>\n          <div className=\"flex-1\">\n            <p className={`font-semibold ${textColor} mb-1`}>\n              {type === 'error' ? 'Error' : type === 'warning' ? 'Warning' : 'Info'}\n            </p>\n            <p className={`text-sm ${textColor}`}>{message}</p>\n          </div>\n        </div>\n        <button\n          onClick={onClose}\n          className={`ml-4 ${textColor} hover:opacity-70`}\n        >\n          \n        </button>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/FixExplanationModal.tsx",
        "content": "'use client';\n\ninterface FixExplanationModalProps {\n  explanation: any;\n  onClose: () => void;\n}\n\nexport default function FixExplanationModal({ explanation, onClose }: FixExplanationModalProps) {\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50\" onClick={onClose}>\n      <div className=\"bg-gray-900 border border-[#2f0012] rounded-lg p-6 max-w-2xl max-h-[80vh] overflow-y-auto\" onClick={(e) => e.stopPropagation()}>\n        <div className=\"flex justify-between items-start mb-4\">\n          <h3 className=\"text-2xl font-semibold text-white\">Fix Explanation</h3>\n          <button onClick={onClose} className=\"text-gray-400 hover:text-white transition-colors\"></button>\n        </div>\n        \n        <div className=\"space-y-4\">\n          <div>\n            <h4 className=\"font-semibold text-white mb-2\">Why is this dangerous?</h4>\n            <p className=\"text-sm text-gray-300\">{explanation.whyDangerous}</p>\n          </div>\n          \n          <div>\n            <h4 className=\"font-semibold text-white mb-2\">How to fix manually:</h4>\n            <p className=\"text-sm text-gray-300 whitespace-pre-wrap\">{explanation.howToFixManually}</p>\n          </div>\n          \n          <div>\n            <h4 className=\"font-semibold text-white mb-2\">Impact:</h4>\n            <p className=\"text-sm text-gray-300\">{explanation.impact}</p>\n          </div>\n          \n          <div className=\"grid grid-cols-3 gap-4\">\n            <div className=\"bg-gray-800 p-3 rounded-lg\">\n              <p className=\"text-sm text-gray-400 mb-1\">Priority</p>\n              <p className=\"font-semibold text-white\">{explanation.priority}</p>\n            </div>\n            <div className=\"bg-gray-800 p-3 rounded-lg\">\n              <p className=\"text-sm text-gray-400 mb-1\">Estimated Time</p>\n              <p className=\"font-semibold text-white\">{explanation.estimatedTime}</p>\n            </div>\n            <div className=\"bg-gray-800 p-3 rounded-lg\">\n              <p className=\"text-sm text-gray-400 mb-1\">Difficulty</p>\n              <p className=\"font-semibold text-white\">{explanation.difficulty}</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/GitHubConnect.tsx",
        "content": "'use client';\n\ninterface GitHubConnectProps {\n  repoUrl: string;\n  onRepoUrlChange: (url: string) => void;\n}\n\nexport default function GitHubConnect({ repoUrl, onRepoUrlChange }: GitHubConnectProps) {\n  return (\n    <div className=\"bg-[#171717] border border-[#2f0012] rounded-lg p-6 flex items-center justify-between\">\n      <div className=\"flex items-center gap-3\">\n        <svg className=\"w-6 h-6 text-gray-500\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path d=\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"/>\n        </svg>\n        <div>\n          <h3 className=\"text-lg font-semibold text-white mb-1\">Import your repos</h3>\n          <p className=\"text-sm text-gray-500\">Connect your GitHub repositories for testing</p>\n        </div>\n      </div>\n      <div className=\"flex items-center gap-3\">\n        <input\n          type=\"text\"\n          value={repoUrl}\n          onChange={(e) => onRepoUrlChange(e.target.value)}\n          placeholder=\"https://github.com/user/repo\"\n          className=\"bg-[#1f1f1f] border border-[#2f0012] text-white px-4 py-2 rounded-lg focus:outline-none focus:ring-1 focus:ring-gray-700 w-64\"\n        />\n        <button className=\"bg-[#1f1f1f] hover:bg-[#2a2a2a] text-white px-4 py-2 rounded-lg flex items-center gap-2 transition-colors border border-[#2f0012]\">\n          <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path d=\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"/>\n          </svg>\n          <span className=\"text-sm font-medium\">Connect</span>\n        </button>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/Header.tsx",
        "content": "'use client';\n\ninterface HeaderProps {\n  sidebarOpen?: boolean;\n  isMobile?: boolean;\n  onToggleSidebar?: () => void;\n}\n\nexport default function Header({ sidebarOpen = true, isMobile = false, onToggleSidebar }: HeaderProps) {\n  return (\n    <div className={`h-16 bg-[#0f0f0f] border-b border-[#2f0012] flex items-center justify-between ${isMobile ? 'px-4' : 'px-6'} fixed top-0 z-10 transition-all duration-300 ${\n      isMobile \n        ? 'left-0 right-0' \n        : (sidebarOpen ? 'left-64 right-0' : 'left-16 right-0')\n    }`}>\n      <div className=\"flex items-center gap-3 md:gap-4\">\n        {isMobile && onToggleSidebar && (\n          <button\n            onClick={onToggleSidebar}\n            className=\"p-2 text-gray-400 hover:text-white transition-colors\"\n          >\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h16\" />\n            </svg>\n          </button>\n        )}\n        <select className={`bg-[#1f1f1f] text-white ${isMobile ? 'px-2 py-1 text-xs' : 'px-4 py-2 text-sm'} rounded-lg border border-[#2f0012] focus:outline-none focus:ring-1 focus:ring-gray-700`}>\n          <option>Gemini 3 Flash</option>\n          <option>Gemini 2.5 Flash</option>\n          <option>Gemini 1.5 Flash</option>\n        </select>\n      </div>\n\n      <div className=\"flex items-center gap-2 md:gap-3\">\n        {!isMobile && (\n          <button className=\"text-gray-500 hover:text-white transition-colors\">\n            <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n            </svg>\n          </button>\n        )}\n        \n        <button className={`text-gray-500 hover:text-white transition-colors flex items-center gap-2 ${isMobile ? 'px-2 py-1' : 'px-3 py-1.5'} rounded-lg hover:bg-[#1f1f1f]`}>\n          <svg className={`${isMobile ? 'w-3 h-3' : 'w-4 h-4'}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z\" />\n          </svg>\n          {!isMobile && <span className=\"text-sm\">Feedback</span>}\n        </button>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem.tsx",
        "content": "'use client';\n\nimport { useState, useEffect } from 'react';\nimport BusinessImpactSection from './IssueItem/BusinessImpactSection';\nimport ExplainFixSection from './IssueItem/ExplainFixSection';\nimport SmartFixSection from './IssueItem/SmartFixSection';\nimport ReasoningChainSection from './IssueItem/ReasoningChainSection';\nimport ActionButtons from './IssueItem/ActionButtons';\nimport IssueHeader from './IssueItem/IssueHeader';\nimport type { IssueItemProps, BusinessImpactData } from '@/lib/types';\n\nexport default function IssueItem({ issue, cachedData = {}, sessionId, onExplainFix, onSmartFix, onReasoningChain }: IssueItemProps) {\n  const [loading, setLoading] = useState<'explain' | 'smart' | 'reasoning' | null>(null);\n  const [businessImpact, setBusinessImpact] = useState<BusinessImpactData | null>(null);\n  const [loadingImpact, setLoadingImpact] = useState(false);\n  const [expandedSections, setExpandedSections] = useState<{\n    explain: boolean;\n    smart: boolean;\n    reasoning: boolean;\n  }>({\n    explain: false,\n    smart: false,\n    reasoning: false\n  });\n  \n  // Read directly from cachedData (no local state caching)\n  const localData = {\n    explainFix: cachedData?.explainFix,\n    smartFix: cachedData?.smartFix,\n    reasoningChain: cachedData?.reasoningChain\n  };\n  \n  useEffect(() => {\n    // Try to load from cachedData first\n    if (cachedData?.businessImpact) {\n      setBusinessImpact(cachedData.businessImpact);\n      return;\n    }\n    \n    // Load business impact on mount\n    if (issue && !businessImpact && !loadingImpact) {\n      loadBusinessImpact();\n    }\n  }, [issue, cachedData]);\n\n  const getIssueKey = () => {\n    return `${issue.file}-${issue.type}-${issue.severity}-${issue.description.substring(0, 50)}`;\n  };\n\n  const loadBusinessImpact = async () => {\n    setLoadingImpact(true);\n    try {\n      const response = await fetch('/api/business-impact', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ issue })\n      });\n      const data = await response.json();\n      if (data.success && data.impact) {\n        setBusinessImpact(data.impact);\n        \n        // Save to session\n        if (sessionId) {\n          await saveBusinessImpactToSession(data.impact);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to load business impact:', error);\n    } finally {\n      setLoadingImpact(false);\n    }\n  };\n\n  const saveBusinessImpactToSession = async (impact: BusinessImpactData): Promise<void> => {\n    if (!sessionId) return;\n    \n    try {\n      const issueKey = getIssueKey();\n      await fetch(`/api/sessions/${sessionId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          businessImpactData: {\n            [issueKey]: impact\n          }\n        })\n      });\n    } catch (error) {\n      console.error('Failed to save business impact to session:', error);\n    }\n  };\n\n  const handleAction = async (action: 'explain' | 'smart' | 'reasoning', callback: () => Promise<any>) => {\n    // If already cached, just expand\n    if (action === 'explain' && localData.explainFix) {\n      setExpandedSections(prev => ({ ...prev, explain: !prev.explain }));\n      return;\n    }\n    if (action === 'smart' && localData.smartFix) {\n      setExpandedSections(prev => ({ ...prev, smart: !prev.smart }));\n      return;\n    }\n    if (action === 'reasoning' && localData.reasoningChain) {\n      setExpandedSections(prev => ({ ...prev, reasoning: !prev.reasoning }));\n      return;\n    }\n\n    // Otherwise, fetch and expand\n    setLoading(action);\n    try {\n      const result = await callback();\n      if (result) {\n        // Data is saved to session by the callback, just expand the section\n        if (action === 'explain') {\n          setExpandedSections(prev => ({ ...prev, explain: true }));\n        } else if (action === 'smart') {\n          setExpandedSections(prev => ({ ...prev, smart: true }));\n        } else if (action === 'reasoning') {\n          setExpandedSections(prev => ({ ...prev, reasoning: true }));\n        }\n      }\n    } finally {\n      setLoading(null);\n    }\n  };\n\n  return (\n    <div className=\"border border-[#2f0012] rounded-lg p-4 bg-gray-800/50 hover:bg-gray-800 transition-colors\">\n      <div className=\"flex justify-between items-start\">\n        <div className=\"flex-1\">\n          <IssueHeader issue={issue} businessImpact={businessImpact || undefined} />\n          <BusinessImpactSection businessImpact={businessImpact || undefined} />\n        </div>\n        <ActionButtons\n          loading={loading}\n          cachedData={localData}\n          onExplainFix={() => handleAction('explain', onExplainFix)}\n          onSmartFix={() => handleAction('smart', onSmartFix)}\n          onReasoningChain={() => handleAction('reasoning', onReasoningChain)}\n        />\n      </div>\n      \n      <ExplainFixSection \n        explainFix={localData.explainFix} \n        isExpanded={expandedSections.explain}\n        onClose={() => setExpandedSections(prev => ({ ...prev, explain: false }))}\n      />\n      <SmartFixSection \n        smartFix={localData.smartFix} \n        isExpanded={expandedSections.smart}\n        onClose={() => setExpandedSections(prev => ({ ...prev, smart: false }))}\n      />\n      <ReasoningChainSection \n        reasoningChain={localData.reasoningChain} \n        isExpanded={expandedSections.reasoning}\n        onClose={() => setExpandedSections(prev => ({ ...prev, reasoning: false }))}\n      />\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/ActionButtons.tsx",
        "content": "'use client';\n\nimport type { IssueData } from '@/lib/types';\n\ninterface ActionButtonsProps {\n  loading: 'explain' | 'smart' | 'reasoning' | null;\n  cachedData: IssueData;\n  onExplainFix: () => void;\n  onSmartFix: () => void;\n  onReasoningChain: () => void;\n}\n\nexport default function ActionButtons({ loading, cachedData, onExplainFix, onSmartFix, onReasoningChain }: ActionButtonsProps) {\n  return (\n    <div className=\"flex flex-wrap gap-2 ml-4\">\n      <button\n        onClick={onExplainFix}\n        disabled={loading !== null}\n        className={`text-sm px-3 py-1.5 rounded border border-[#2f0012] transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 min-w-[110px] justify-center ${\n          cachedData.explainFix \n            ? 'bg-blue-700/50 hover:bg-blue-700/70 text-blue-200' \n            : 'bg-blue-900/30 hover:bg-blue-900/50 text-blue-300'\n        }`}\n      >\n        {loading === 'explain' ? (\n          <>\n            <svg className=\"animate-spin h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n              <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n              <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n            </svg>\n            <span>Loading...</span>\n          </>\n        ) : (\n          <>\n            {cachedData.explainFix ? ' ' : ''}Explain Fix\n          </>\n        )}\n      </button>\n      <button\n        onClick={onSmartFix}\n        disabled={loading !== null}\n        className={`text-sm px-3 py-1.5 rounded border border-[#2f0012] transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 min-w-[110px] justify-center ${\n          cachedData.smartFix \n            ? 'bg-green-700/50 hover:bg-green-700/70 text-green-200' \n            : 'bg-green-900/30 hover:bg-green-900/50 text-green-300'\n        }`}\n      >\n        {loading === 'smart' ? (\n          <>\n            <svg className=\"animate-spin h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n              <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n              <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n            </svg>\n            <span>Loading...</span>\n          </>\n        ) : (\n          <>\n            {cachedData.smartFix ? ' ' : ''}Smart Fix\n          </>\n        )}\n      </button>\n      <button\n        onClick={onReasoningChain}\n        disabled={loading !== null}\n        className={`text-sm px-3 py-1.5 rounded border border-[#2f0012] transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 min-w-[110px] justify-center ${\n          cachedData.reasoningChain \n            ? 'bg-purple-700/50 hover:bg-purple-700/70 text-purple-200' \n            : 'bg-purple-900/30 hover:bg-purple-900/50 text-purple-300'\n        }`}\n      >\n        {loading === 'reasoning' ? (\n          <>\n            <svg className=\"animate-spin h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\n              <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n              <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n            </svg>\n            <span>Loading...</span>\n          </>\n        ) : (\n          <>\n            {cachedData.reasoningChain ? ' ' : ''} Reasoning\n          </>\n        )}\n      </button>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/BusinessImpactSection.tsx",
        "content": "'use client';\n\nimport type { BusinessImpactData } from '@/lib/types';\n\ninterface BusinessImpactSectionProps {\n  businessImpact?: BusinessImpactData;\n}\n\nexport default function BusinessImpactSection({ businessImpact }: BusinessImpactSectionProps) {\n  if (!businessImpact) return null;\n\n  return (\n    <div className=\"mt-3 p-3 bg-blue-900/20 border border-blue-800/30 rounded-lg\">\n      <p className=\"text-xs font-semibold text-blue-300 mb-1\"> Business Impact</p>\n      <p className=\"text-xs text-blue-200\">{businessImpact.explanation}</p>\n      {businessImpact.realWorldExample && (\n        <p className=\"text-xs text-blue-300 mt-2 italic\">\n           Example: {businessImpact.realWorldExample}\n        </p>\n      )}\n      {businessImpact.estimatedCost && (\n        <div className=\"mt-2 flex flex-wrap gap-2 text-xs\">\n          {businessImpact.estimatedCost.revenue && (\n            <span className=\"text-red-300\"> {businessImpact.estimatedCost.revenue}</span>\n          )}\n          {businessImpact.estimatedCost.users && (\n            <span className=\"text-yellow-300\"> {businessImpact.estimatedCost.users}</span>\n          )}\n          {businessImpact.estimatedCost.time && (\n            <span className=\"text-green-300\"> {businessImpact.estimatedCost.time}</span>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/ExplainFixSection.tsx",
        "content": "'use client';\n\nimport type { ExplainFixData } from '@/lib/types';\n\ninterface ExplainFixSectionProps {\n  explainFix?: ExplainFixData;\n  isExpanded: boolean;\n  onClose?: () => void;\n}\n\nexport default function ExplainFixSection({ explainFix, isExpanded, onClose }: ExplainFixSectionProps) {\n  if (!isExpanded || !explainFix) return null;\n\n  return (\n    <div className=\"mt-3 p-4 bg-blue-900/20 border border-blue-800/30 rounded-lg\">\n      <div className=\"flex justify-between items-start mb-2\">\n        <h4 className=\"text-sm font-semibold text-blue-300\"> Fix Explanation</h4>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"text-blue-400 hover:text-blue-300 text-xs\"\n          >\n            \n          </button>\n        )}\n      </div>\n      <div className=\"space-y-3 text-xs\">\n        <div>\n          <p className=\"text-blue-200 font-semibold mb-1\">Why is this dangerous?</p>\n          <p className=\"text-blue-100\">{explainFix.whyDangerous}</p>\n        </div>\n        <div>\n          <p className=\"text-blue-200 font-semibold mb-1\">How to fix manually:</p>\n          <pre className=\"text-blue-100 whitespace-pre-wrap bg-blue-950/30 p-2 rounded\">{explainFix.howToFixManually}</pre>\n        </div>\n        <div>\n          <p className=\"text-blue-200 font-semibold mb-1\">Impact:</p>\n          <p className=\"text-blue-100\">{explainFix.impact}</p>\n        </div>\n        {explainFix.priority && (\n          <div className=\"grid grid-cols-3 gap-2 text-xs\">\n            <div>\n              <p className=\"text-blue-300\">Priority</p>\n              <p className=\"text-blue-100 font-semibold capitalize\">{explainFix.priority}</p>\n            </div>\n            {explainFix.estimatedTime && (\n              <div>\n                <p className=\"text-blue-300\">Time</p>\n                <p className=\"text-blue-100 font-semibold\">{explainFix.estimatedTime}</p>\n              </div>\n            )}\n            {explainFix.difficulty && (\n              <div>\n                <p className=\"text-blue-300\">Difficulty</p>\n                <p className=\"text-blue-100 font-semibold capitalize\">{explainFix.difficulty}</p>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/IssueHeader.tsx",
        "content": "'use client';\n\nimport type { CodeIssue, BusinessImpactData } from '@/lib/types';\n\ninterface IssueHeaderProps {\n  issue: CodeIssue;\n  businessImpact?: BusinessImpactData;\n}\n\nexport default function IssueHeader({ issue, businessImpact }: IssueHeaderProps) {\n  const severityIcon = issue.severity === 'high' ? '' : issue.severity === 'medium' ? '' : '';\n  \n  const getImpactColor = (score?: number) => {\n    if (!score) return 'text-gray-400';\n    if (score >= 75) return 'text-red-400';\n    if (score >= 50) return 'text-yellow-400';\n    return 'text-green-400';\n  };\n\n  return (\n    <div className=\"flex-1\">\n      <div className=\"flex items-center gap-3 mb-2\">\n        <p className=\"font-semibold text-white\">\n          {issue.type} - {issue.severity} {severityIcon}\n        </p>\n        {businessImpact?.impactScore !== undefined && (\n          <div className={`flex items-center gap-1 ${getImpactColor(businessImpact.impactScore)}`}>\n            <span className=\"text-xs font-semibold\">Impact:</span>\n            <span className=\"text-sm font-bold\">{businessImpact.impactScore}/100</span>\n          </div>\n        )}\n      </div>\n      <p className=\"text-sm text-gray-400 mt-1\">{issue.file}</p>\n      <p className=\"text-sm text-gray-300 mt-1\">{issue.description}</p>\n      {issue.suggestion && (\n        <p className=\"text-sm text-gray-400 mt-2\"> {issue.suggestion}</p>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/ReasoningChainSection.tsx",
        "content": "'use client';\n\nimport type { ReasoningChainData, ReasoningStep } from '@/lib/types';\n\ninterface ReasoningChainSectionProps {\n  reasoningChain?: ReasoningChainData;\n  isExpanded: boolean;\n  onClose?: () => void;\n}\n\nexport default function ReasoningChainSection({ reasoningChain, isExpanded, onClose }: ReasoningChainSectionProps) {\n  if (!isExpanded || !reasoningChain) return null;\n\n  return (\n    <div className=\"mt-3 p-4 bg-purple-900/20 border border-purple-800/30 rounded-lg\">\n      <div className=\"flex justify-between items-start mb-2\">\n        <h4 className=\"text-sm font-semibold text-purple-300\"> Reasoning Chain</h4>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"text-purple-400 hover:text-purple-300 text-xs\"\n          >\n            \n          </button>\n        )}\n      </div>\n          <div className=\"space-y-3 text-xs max-h-96 overflow-y-auto\">\n        {reasoningChain.steps && reasoningChain.steps.map((step: any, idx: number) => (\n              <div key={idx} className=\"border-l-2 border-purple-500 pl-3 py-2 bg-purple-950/20 rounded-r\">\n                <div className=\"flex items-center gap-2 mb-1\">\n                  <span className=\"bg-purple-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold\">\n                    {step.step || idx + 1}\n                  </span>\n                  <span className={`text-xs px-2 py-0.5 rounded ${\n                    step.confidence === 'high' ? 'bg-green-900/30 text-green-300' :\n                    step.confidence === 'medium' ? 'bg-yellow-900/30 text-yellow-300' :\n                    'bg-gray-800 text-gray-300'\n                  }`}>\n                    {step.confidence || 'medium'} confidence\n                  </span>\n                </div>\n                {step.thought && (\n                  <div className=\"mb-1\">\n                    <p className=\"text-purple-200 font-semibold text-xs\"> Thought:</p>\n                    <p className=\"text-purple-100 text-xs\">{step.thought}</p>\n                  </div>\n                )}\n                {step.analysis && (\n                  <div className=\"mb-1\">\n                    <p className=\"text-purple-200 font-semibold text-xs\"> Analysis:</p>\n                    <p className=\"text-purple-100 text-xs\">{step.analysis}</p>\n                  </div>\n                )}\n                {step.conclusion && (\n                  <div>\n                    <p className=\"text-purple-200 font-semibold text-xs\"> Conclusion:</p>\n                    <p className=\"text-purple-100 text-xs font-semibold\">{step.conclusion}</p>\n                  </div>\n                )}\n              </div>\n        ))}\n            {reasoningChain.reasoningPath && (\n              <div className=\"mt-3 bg-purple-950/30 p-2 rounded\">\n                <p className=\"text-purple-200 font-semibold text-xs mb-1\"> Reasoning Path:</p>\n                <p className=\"text-purple-100 text-xs\">{reasoningChain.reasoningPath}</p>\n              </div>\n            )}\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssueItem/SmartFixSection.tsx",
        "content": "'use client';\n\nimport type { SmartFixData } from '@/lib/types';\n\ninterface SmartFixSectionProps {\n  smartFix?: SmartFixData;\n  isExpanded: boolean;\n  onClose?: () => void;\n}\n\nexport default function SmartFixSection({ smartFix, isExpanded, onClose }: SmartFixSectionProps) {\n  if (!isExpanded || !smartFix) return null;\n\n  return (\n    <div className=\"mt-3 p-4 bg-green-900/20 border border-green-800/30 rounded-lg\">\n      <div className=\"flex justify-between items-start mb-2\">\n        <h4 className=\"text-sm font-semibold text-green-300\"> Smart Fix</h4>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"text-green-400 hover:text-green-300 text-xs\"\n          >\n            \n          </button>\n        )}\n      </div>\n          <div className=\"space-y-2 text-xs\">\n        {smartFix.fixedCode && (\n          <div>\n            <p className=\"text-green-200 font-semibold mb-1\">Fixed Code:</p>\n            <pre className=\"text-green-100 whitespace-pre-wrap bg-green-950/30 p-2 rounded text-xs overflow-x-auto\">{smartFix.fixedCode}</pre>\n          </div>\n        )}\n        {smartFix.explanation && (\n          <div>\n            <p className=\"text-green-200 font-semibold mb-1\">Explanation:</p>\n            <p className=\"text-green-100\">{smartFix.explanation}</p>\n          </div>\n        )}\n        {smartFix.businessLogicConsiderations && (\n          <div>\n            <p className=\"text-green-200 font-semibold mb-1\">Business Logic:</p>\n            <p className=\"text-green-100\">{smartFix.businessLogicConsiderations}</p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/IssuesList.tsx",
        "content": "'use client';\n\nimport { useEffect } from 'react';\nimport IssueItem from './IssueItem';\nimport type { SessionResults, CodeIssue, IssueData, ExplainFixData, SmartFixData, ReasoningChainData } from '@/lib/types';\n\ninterface IssuesListProps {\n  results: SessionResults;\n  sessionId?: string;\n  onError?: (message: string, type?: 'error' | 'warning' | 'info') => void;\n}\n\nfunction parseErrorMessage(message: unknown): string {\n  if (!message) return 'Unknown error occurred';\n  \n  try {\n    const errorObj = typeof message === 'string' ? JSON.parse(message) : message;\n    if (errorObj.error?.code === 429 || errorObj.error?.status === 'RESOURCE_EXHAUSTED') {\n      return 'API quota exceeded. The free tier allows 20 requests per day. Please wait or use a different API key.';\n    }\n    return errorObj.error?.message || (typeof message === 'string' ? message : JSON.stringify(message));\n  } catch {\n    const msg = typeof message === 'string' ? message : 'Unknown error occurred';\n    if (msg.includes('429') || msg.includes('quota') || msg.includes('RESOURCE_EXHAUSTED')) {\n      return 'API quota exceeded. The free tier allows 20 requests per day. Please wait or use a different API key.';\n    }\n    return msg;\n  }\n}\n\nfunction isQuotaError(errorMsg: string): boolean {\n  return errorMsg.includes('quota') || errorMsg.includes('429') || errorMsg.includes('RESOURCE_EXHAUSTED');\n}\n\nasync function handleApiCall(\n  endpoint: string,\n  body: any,\n  onSuccess: (data: any) => void,\n  onError?: (message: string, type?: 'error' | 'warning' | 'info') => void\n): Promise<string | null> {\n  try {\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body)\n    });\n    const data = await response.json();\n    if (data.success) {\n      onSuccess(data);\n      return null;\n    } else {\n      const errorMsg = parseErrorMessage(data.message);\n      onError?.(`Request failed: ${errorMsg}`, isQuotaError(errorMsg) ? 'warning' : 'error');\n      return errorMsg;\n    }\n    } catch (error: unknown) {\n      const errorMsg = parseErrorMessage(error instanceof Error ? error.message : String(error));\n      onError?.(`Error: ${errorMsg}`, isQuotaError(errorMsg) ? 'warning' : 'error');\n      return errorMsg;\n    }\n}\n\nexport default function IssuesList({ results, sessionId, onError }: IssuesListProps) {\n  // Load issueData directly from results (no local state caching)\n  const issueData = results.issueData || {};\n\n  // Initialize issueData in results if not exists\n  useEffect(() => {\n    if (!results.issueData) {\n      results.issueData = {};\n    }\n  }, [results]);\n\n  const getFiles = () => {\n    const files = results.files || [];\n    if (files.length === 0) {\n      onError?.('No files available. Please try again after analysis completes.', 'warning');\n      return null;\n    }\n    return files;\n  };\n\n  const getIssueKey = (issue: CodeIssue): string => {\n    return `${issue.file}-${issue.type}-${issue.severity}-${issue.description.substring(0, 50)}`;\n  };\n\n  const saveIssueDataToSession = async (issueKey: string, data: Partial<IssueData>): Promise<void> => {\n    if (!sessionId) return;\n    \n    try {\n      const updatedIssueData = {\n        ...issueData,\n        [issueKey]: {\n          ...issueData[issueKey],\n          ...data\n        }\n      };\n      \n      // Update results directly (no local state)\n      results.issueData = updatedIssueData;\n      \n      // Save to session file\n      await fetch(`/api/sessions/${sessionId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ issueData: updatedIssueData })\n      });\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to save issue data to session';\n      onError?.(errorMessage, 'error');\n    }\n  };\n\n  const handleExplainFix = async (issue: CodeIssue): Promise<ExplainFixData | null> => {\n    const issueKey = getIssueKey(issue);\n    \n    // Check if already in session\n    if (issueData[issueKey]?.explainFix) {\n      return issueData[issueKey].explainFix;\n    }\n\n    const files = getFiles();\n    if (!files) return null;\n\n    return new Promise(async (resolve, reject) => {\n      const errorMsg = await handleApiCall(\n        '/api/explain-fix',\n        { issues: [issue], files },\n        async (data: { explanations?: ExplainFixData[] }) => {\n          if (data.explanations && data.explanations.length > 0) {\n            const explanation = data.explanations[0];\n            await saveIssueDataToSession(issueKey, { explainFix: explanation });\n            resolve(explanation);\n          } else {\n            reject(new Error('No explanation generated'));\n          }\n        },\n        (msg) => {\n          onError?.(msg);\n        }\n      );\n      if (errorMsg) {\n        reject(new Error(errorMsg));\n      }\n    });\n  };\n\n  const handleSmartFix = async (issue: CodeIssue): Promise<SmartFixData | null> => {\n    const issueKey = getIssueKey(issue);\n    \n    // Check if already in session\n    if (issueData[issueKey]?.smartFix) {\n      return issueData[issueKey].smartFix;\n    }\n\n    const files = getFiles();\n    if (!files) return null;\n\n    const fileContent = files.find((f: any) => f.path === issue.file)?.content || '';\n    if (!fileContent) {\n      onError?.(`File content not found for: ${issue.file}`, 'warning');\n      return null;\n    }\n\n    return new Promise(async (resolve, reject) => {\n      const errorMsg = await handleApiCall(\n        '/api/context-aware-fix',\n        {\n          issue,\n          fileContent,\n          codebaseContext: files.map((f) => f.content).join('\\n\\n')\n        },\n        async (data: SmartFixData) => {\n          await saveIssueDataToSession(issueKey, { smartFix: data });\n          resolve(data);\n        },\n        (msg) => {\n          onError?.(msg);\n        }\n      );\n      if (errorMsg) {\n        reject(new Error(errorMsg));\n      }\n    });\n  };\n\n  const handleReasoningChain = async (issue: CodeIssue): Promise<ReasoningChainData | null> => {\n    const issueKey = getIssueKey(issue);\n    \n    // Check if already in session\n    if (issueData[issueKey]?.reasoningChain) {\n      return issueData[issueKey].reasoningChain;\n    }\n\n    const files = getFiles();\n    if (!files) return null;\n\n    const fileContent = files.find((f: any) => f.path === issue.file)?.content || '';\n    return new Promise(async (resolve, reject) => {\n      const errorMsg = await handleApiCall(\n        '/api/reasoning-chain',\n        {\n          issue,\n          fileContent,\n          codebaseContext: files.map((f) => f.content).join('\\n\\n')\n        },\n        async (data: { chain?: ReasoningChainData }) => {\n          if (data.chain) {\n            await saveIssueDataToSession(issueKey, { reasoningChain: data.chain });\n            resolve(data.chain);\n          } else {\n            reject(new Error('No reasoning chain generated'));\n          }\n        },\n        (msg) => {\n          onError?.(msg);\n        }\n      );\n      if (errorMsg) {\n        reject(new Error(errorMsg));\n      }\n    });\n  };\n\n  return (\n    <div className=\"mt-4\">\n      <h3 className=\"text-xl font-semibold mb-2 text-white\">Issues</h3>\n      <div className=\"space-y-2\">\n        {results.analysis.issues.map((issue: CodeIssue, index: number) => {\n          const issueKey = getIssueKey(issue);\n          const cached = issueData[issueKey] || {};\n          \n          // Add businessImpact from results.businessImpactData if available\n          const businessImpactKey = `${issue.file}-${issue.type}-${issue.severity}-${issue.description.substring(0, 50)}`;\n          const businessImpact = results.businessImpactData?.[businessImpactKey];\n          \n          return (\n            <IssueItem\n              key={index}\n              issue={issue}\n              cachedData={{ ...cached, businessImpact }}\n              sessionId={sessionId}\n              onExplainFix={() => handleExplainFix(issue)}\n              onSmartFix={() => handleSmartFix(issue)}\n              onReasoningChain={() => handleReasoningChain(issue)}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/LoadingSpinner.tsx",
        "content": "'use client';\n\ninterface LoadingSpinnerProps {\n  progress: { step: string; percentage: number };\n}\n\nexport default function LoadingSpinner({ progress }: LoadingSpinnerProps) {\n  return (\n    <div className=\"mt-8 bg-[#171717] border border-[#2f0012] rounded-lg p-6\">\n      <div className=\"text-center\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-gray-600 mx-auto mb-4\"></div>\n        <p className=\"text-lg font-semibold text-white\">{progress.step}</p>\n        <div className=\"w-full bg-gray-800 rounded-full h-2.5 mt-4 mb-2\">\n          <div \n            className=\"bg-gray-600 h-2.5 rounded-full transition-all duration-300\" \n            style={{ width: `${progress.percentage}%` }}\n          ></div>\n        </div>\n        <p className=\"text-sm text-gray-400\">{progress.percentage}%</p>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ReasoningChainModal.tsx",
        "content": "'use client';\n\ninterface ReasoningChainModalProps {\n  chain: any;\n  onClose: () => void;\n}\n\nexport default function ReasoningChainModal({ chain, onClose }: ReasoningChainModalProps) {\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50\" onClick={onClose}>\n      <div className=\"bg-gray-900 border border-[#2f0012] rounded-lg p-6 max-w-3xl max-h-[80vh] overflow-y-auto\" onClick={(e) => e.stopPropagation()}>\n        <div className=\"flex justify-between items-start mb-4\">\n          <h3 className=\"text-2xl font-semibold text-white\"> Reasoning Chain</h3>\n          <button onClick={onClose} className=\"text-gray-400 hover:text-white transition-colors\"></button>\n        </div>\n        \n        <div className=\"mb-4\">\n          <p className=\"text-sm text-gray-400 mb-2\">Issue: {chain.issue?.type} - {chain.issue?.severity}</p>\n          <p className=\"text-sm text-white\">{chain.issue?.description}</p>\n        </div>\n\n        <div className=\"space-y-4 mb-4\">\n          {chain.steps && chain.steps.map((step: any, index: number) => (\n            <div key={index} className=\"border-l-4 border-purple-500 pl-4 py-2 bg-purple-900/20 rounded-r\">\n              <div className=\"flex items-center mb-2\">\n                <span className=\"bg-purple-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold mr-2\">\n                  {step.step}\n                </span>\n                <span className={`text-xs px-2 py-1 rounded ${\n                  step.confidence === 'high' ? 'bg-green-900/30 text-green-300 border border-[#2f0012]' :\n                  step.confidence === 'medium' ? 'bg-yellow-900/30 text-yellow-300 border border-[#2f0012]' :\n                  'bg-gray-800 text-gray-300 border border-gray-700'\n                }`}>\n                  {step.confidence} confidence\n                </span>\n              </div>\n              <div className=\"space-y-2\">\n                <div>\n                  <p className=\"text-xs font-semibold text-gray-400\"> Thought:</p>\n                  <p className=\"text-sm text-gray-300\">{step.thought}</p>\n                </div>\n                <div>\n                  <p className=\"text-xs font-semibold text-gray-400\"> Analysis:</p>\n                  <p className=\"text-sm text-gray-300\">{step.analysis}</p>\n                </div>\n                <div>\n                  <p className=\"text-xs font-semibold text-gray-400\"> Conclusion:</p>\n                  <p className=\"text-sm text-white font-semibold\">{step.conclusion}</p>\n                </div>\n              </div>\n            </div>\n          ))}\n        </div>\n\n        {chain.reasoningPath && (\n          <div className=\"mb-4 bg-gray-800 p-3 rounded-lg\">\n            <p className=\"text-xs font-semibold text-gray-400 mb-1\"> Reasoning Path:</p>\n            <p className=\"text-sm text-gray-300\">{chain.reasoningPath}</p>\n          </div>\n        )}\n\n        {chain.finalDecision && (\n          <div className=\"bg-blue-900/20 p-4 rounded-lg border-l-4 border-blue-500\">\n            <p className=\"text-xs font-semibold text-blue-300 mb-1\"> Final Decision:</p>\n            <p className=\"text-sm text-white font-semibold\">{chain.finalDecision}</p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView.tsx",
        "content": "'use client';\n\nimport { useState } from 'react';\nimport IssuesList from './IssuesList';\nimport RiskTimelineView from './RiskTimelineView';\nimport CodeMetricsView from './CodeMetricsView';\nimport BusinessImpactView from './BusinessImpactView';\nimport SummarySection from './ResultsView/SummarySection';\nimport TestResultsSection from './ResultsView/TestResultsSection';\nimport FixesSection from './ResultsView/FixesSection';\nimport MarathonSection from './ResultsView/MarathonSection';\nimport SuccessMetricsSection from './ResultsView/SuccessMetricsSection';\nimport ViewTabs from './ResultsView/ViewTabs';\nimport type { ResultsViewProps } from '@/lib/types';\n\nexport default function ResultsView({ results, marathonTaskId, sessionId, onStopMarathon, onError, onRegenerateTimeline, onRegenerateMetrics }: ResultsViewProps) {\n  const [selectedView, setSelectedView] = useState<'results' | 'risk-timeline' | 'metrics' | 'business-impact'>('results');\n\n  return (\n    <div className=\"mt-8 bg-[#171717] border border-[#2f0012] rounded-lg p-6\">\n      <h2 className=\"text-2xl font-semibold mb-4 text-white\">Results</h2>\n      \n      <SummarySection results={results} />\n      {results.testResults && <TestResultsSection results={results} />}\n      {results.fixes && <FixesSection results={results} />}\n      {results.marathonTask && (\n        <MarathonSection \n          results={results} \n          marathonTaskId={marathonTaskId || null} \n          onStop={onStopMarathon || (() => {})} \n        />\n      )}\n      \n      <SuccessMetricsSection results={results} />\n\n      <ViewTabs selectedView={selectedView} onViewChange={setSelectedView} />\n\n      {selectedView === 'results' && <IssuesList results={results} sessionId={sessionId || undefined} onError={onError} />}\n      {selectedView === 'risk-timeline' && <RiskTimelineView results={results} onRegenerate={onRegenerateTimeline} />}\n      {selectedView === 'metrics' && <CodeMetricsView results={results} onRegenerate={onRegenerateMetrics} />}\n      {selectedView === 'business-impact' && <BusinessImpactView results={results} sessionId={sessionId || undefined} onError={onError} />}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/FixesSection.tsx",
        "content": "'use client';\n\nimport type { SessionResults } from '@/lib/types';\n\ninterface FixesSectionProps {\n  results: SessionResults;\n}\n\nexport default function FixesSection({ results }: FixesSectionProps) {\n  return (\n    <div className=\"mb-4\">\n      <h3 className=\"text-xl font-semibold mb-2 text-white\">Fixes Generated</h3>\n      <p className=\"text-white\">Total Fixes: {results.fixes.length}</p>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/MarathonSection.tsx",
        "content": "'use client';\n\nimport type { SessionResults } from '@/lib/types';\n\ninterface MarathonSectionProps {\n  results: SessionResults;\n  marathonTaskId: string | null;\n  onStop: () => void;\n}\n\nexport default function MarathonSection({ results, marathonTaskId, onStop }: MarathonSectionProps) {\n  const task = results.marathonTask;\n  if (!task) return null;\n  \n  const runtime = task.startTime ? Math.floor((Date.now() - new Date(task.startTime).getTime()) / 1000 / 60) : 0;\n  \n  return (\n    <div className=\"mb-4 bg-gradient-to-r from-purple-900/20 to-blue-900/20 p-4 rounded-lg border border-purple-800/30\">\n      <div className=\"flex items-center gap-2 mb-3\">\n        <span className=\"text-2xl\"></span>\n        <h3 className=\"text-xl font-semibold text-white\">Marathon Agent - Autonomous Operation</h3>\n      </div>\n      \n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3 mb-3\">\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Status</p>\n          <p className=\"text-sm font-semibold text-green-400 capitalize\">{task.status}</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Runtime</p>\n          <p className=\"text-sm font-semibold text-white\">{runtime} min</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Issues Found</p>\n          <p className=\"text-sm font-semibold text-yellow-400\">{task.issuesFound?.length || 0}</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Tests Run</p>\n          <p className=\"text-sm font-semibold text-blue-400\">{task.testsRun || 0}</p>\n        </div>\n      </div>\n      \n      <div className=\"bg-[#1f1f1f]/30 p-3 rounded border border-[#2f0012] mb-3\">\n        <p className=\"text-xs text-gray-400 mb-1\"> Autonomous Capabilities</p>\n        <ul className=\"text-xs text-gray-300 space-y-1\">\n          <li> Continuous monitoring (24/7)</li>\n          <li> Self-correction based on results</li>\n          <li> Thought Signatures for continuity</li>\n          <li> Automatic change detection</li>\n        </ul>\n      </div>\n      \n      {marathonTaskId && (\n        <button\n          onClick={onStop}\n          className=\"w-full bg-red-900/30 hover:bg-red-900/50 text-red-300 px-4 py-2 rounded border border-red-800/50 hover:border-red-700 transition-colors\"\n        >\n          Stop Marathon Agent\n        </button>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/SuccessMetricsSection.tsx",
        "content": "'use client';\n\nimport type { SessionResults, CodeIssue } from '@/lib/types';\n\ninterface SuccessMetricsSectionProps {\n  results: SessionResults;\n}\n\nexport default function SuccessMetricsSection({ results }: SuccessMetricsSectionProps) {\n  const issues = results.analysis?.issues || [];\n  const highSeverity = issues.filter((i: CodeIssue) => i.severity === 'high').length;\n  const securityIssues = issues.filter((i: CodeIssue) => i.type === 'security').length;\n  const testCoverage = results.testResults?.coverage?.statements || 0;\n  const fixesGenerated = results.fixes?.length || 0;\n  \n  const estimatedTimeSaved = issues.length * 30;\n  const estimatedCostSaved = highSeverity * 1000;\n  \n  return (\n    <div className=\"mb-4 bg-gradient-to-r from-green-900/20 to-blue-900/20 p-4 rounded-lg border border-green-800/30\">\n      <div className=\"flex items-center gap-2 mb-3\">\n        <span className=\"text-2xl\"></span>\n        <h3 className=\"text-xl font-semibold text-white\">Success Metrics</h3>\n      </div>\n      \n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3 mb-3\">\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Issues Prevented</p>\n          <p className=\"text-lg font-bold text-green-400\">{issues.length}</p>\n          <p className=\"text-xs text-gray-500 mt-1\">Before production</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Security Risks</p>\n          <p className=\"text-lg font-bold text-red-400\">{securityIssues}</p>\n          <p className=\"text-xs text-gray-500 mt-1\">Critical vulnerabilities</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Test Coverage</p>\n          <p className=\"text-lg font-bold text-blue-400\">{testCoverage}%</p>\n          <p className=\"text-xs text-gray-500 mt-1\">Automated tests</p>\n        </div>\n        <div className=\"bg-[#1f1f1f]/50 p-3 rounded border border-[#2f0012]\">\n          <p className=\"text-xs text-gray-400\">Auto-Fixes</p>\n          <p className=\"text-lg font-bold text-purple-400\">{fixesGenerated}</p>\n          <p className=\"text-xs text-gray-500 mt-1\">Issues resolved</p>\n        </div>\n      </div>\n      \n      <div className=\"bg-[#1f1f1f]/30 p-3 rounded border border-[#2f0012]\">\n        <p className=\"text-xs text-gray-400 mb-2\"> Estimated Impact</p>\n        <div className=\"grid grid-cols-2 gap-2 text-xs\">\n          <div>\n            <span className=\"text-gray-500\">Time Saved:</span>\n            <span className=\"text-green-400 font-semibold ml-2\">~{estimatedTimeSaved} min</span>\n          </div>\n          <div>\n            <span className=\"text-gray-500\">Cost Prevented:</span>\n            <span className=\"text-green-400 font-semibold ml-2\">~${estimatedCostSaved.toLocaleString()}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/SummarySection.tsx",
        "content": "'use client';\n\nimport type { SessionResults } from '@/lib/types';\n\ninterface SummarySectionProps {\n  results: SessionResults;\n}\n\nexport default function SummarySection({ results }: SummarySectionProps) {\n  const totalRepoFiles = results.analysis.totalRepoFiles || results.analysis.totalFiles;\n  const analyzedFiles = results.analysis.totalFiles;\n  const ignoredFiles = totalRepoFiles > analyzedFiles ? totalRepoFiles - analyzedFiles : 0;\n\n  return (\n    <div className=\"mb-4\">\n      <h3 className=\"text-xl font-semibold mb-2 text-white\">Analysis Summary</h3>\n      \n      <div className=\"bg-[#1f1f1f] p-4 rounded-lg mb-3 border border-[#2f0012]\">\n        <p className=\"text-sm text-gray-400 mb-2\"> Repository Overview</p>\n        <div className=\"grid grid-cols-2 gap-2 text-sm\">\n          <div>\n            <span className=\"text-gray-500\">Total files in repo:</span>\n            <span className=\"font-semibold text-white ml-2\">{totalRepoFiles || 'N/A'}</span>\n          </div>\n          <div>\n            <span className=\"text-gray-500\">Code files analyzed:</span>\n            <span className=\"font-semibold text-gray-300 ml-2\">{analyzedFiles}</span>\n          </div>\n          {ignoredFiles > 0 && (\n            <div className=\"col-span-2\">\n              <span className=\"text-gray-500\">Config/assets ignored:</span>\n              <span className=\"font-semibold text-gray-500 ml-2\">{ignoredFiles}</span>\n              <span className=\"text-xs text-gray-500 ml-2\">(HTML, CSS, images, config files)</span>\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div className=\"space-y-1\">\n        <p className=\"text-white\">\n          <span className=\"font-semibold\">Analyzed Code Files:</span> {analyzedFiles}\n          <span className=\"text-sm text-gray-500 ml-2\">(JavaScript/TypeScript with executable logic)</span>\n        </p>\n        <p className=\"text-white\">\n          <span className=\"font-semibold\">Total Lines Analyzed:</span> {results.analysis.totalLines}\n        </p>\n        <p className=\"text-white\">\n          <span className=\"font-semibold\">Issues Found:</span> {results.analysis.issues.length}\n        </p>\n      </div>\n\n      {ignoredFiles > 0 && (\n        <div className=\"mt-3 bg-[#1f1f1f] p-3 rounded text-sm border border-[#2f0012]\">\n          <p className=\"text-gray-400\">\n             <strong>Why only {analyzedFiles} files?</strong> The agent intentionally focuses on executable code \n            (JS/TS) where real security and runtime risks exist, instead of inflating metrics by counting static assets.\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/TestResultsSection.tsx",
        "content": "'use client';\n\nimport type { SessionResults } from '@/lib/types';\n\ninterface TestResultsSectionProps {\n  results: SessionResults;\n}\n\nexport default function TestResultsSection({ results }: TestResultsSectionProps) {\n  return (\n    <div className=\"mb-4\">\n      <h3 className=\"text-xl font-semibold mb-2 text-white\">Tests Generated</h3>\n      <p className=\"text-white\">Total Tests: {results.tests.total}</p>\n      <p className=\"text-white\">Unit Tests: {results.tests.unitTests.length}</p>\n      <p className=\"text-white\">Integration Tests: {results.tests.integrationTests.length}</p>\n      <p className=\"text-white\">Security Tests: {results.tests.securityTests.length}</p>\n      {results.tests.performanceTests && results.tests.performanceTests.length > 0 && (\n        <p className=\"text-white\">Performance Tests: {results.tests.performanceTests.length}</p>\n      )}\n      \n      {results.testResults && (\n        <div className=\"mt-4\">\n          <h4 className=\"font-semibold text-white mb-2\">Test Results</h4>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"bg-green-900/20 border border-[#2f0012] p-3 rounded\">\n              <p className=\"text-sm text-gray-400\">Passed</p>\n              <p className=\"text-2xl font-bold text-green-400\">{results.testResults.passed}</p>\n            </div>\n            <div className=\"bg-red-900/20 border border-[#2f0012] p-3 rounded\">\n              <p className=\"text-sm text-gray-400\">Failed</p>\n              <p className=\"text-2xl font-bold text-red-400\">{results.testResults.failed}</p>\n            </div>\n          </div>\n          {results.testResults.coverage && (\n            <div className=\"mt-4\">\n              <p className=\"text-sm text-white mb-2\">Coverage: {results.testResults.coverage.statements}%</p>\n              <div className=\"w-full bg-gray-800 rounded-full h-2\">\n                <div \n                  className=\"bg-gray-600 h-2 rounded-full\" \n                  style={{ width: `${results.testResults.coverage.statements}%` }}\n                ></div>\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/ResultsView/ViewTabs.tsx",
        "content": "'use client';\n\ninterface ViewTabsProps {\n  selectedView: string;\n  onViewChange: (view: 'results' | 'risk-timeline' | 'metrics' | 'business-impact') => void;\n}\n\nexport default function ViewTabs({ selectedView, onViewChange }: ViewTabsProps) {\n  return (\n    <div className=\"mb-4 flex space-x-2 border-b border-[#2f0012]\">\n      {(['results', 'risk-timeline', 'metrics', 'business-impact'] as const).map(view => (\n        <button\n          key={view}\n          onClick={() => onViewChange(view)}\n          className={`px-4 py-2 font-semibold transition-colors ${\n            selectedView === view \n              ? 'border-b-2 border-gray-600 text-white' \n              : 'text-gray-500 hover:text-gray-300'\n          }`}\n        >\n          {view === 'results' ? 'Issues' : \n           view === 'risk-timeline' ? 'Risk Timeline' : \n           view === 'metrics' ? 'Code Metrics' : \n           'Business Impact'}\n        </button>\n      ))}\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/RiskTimelineView.tsx",
        "content": "'use client';\n\nimport { useState } from 'react';\n\ninterface RiskTimelineViewProps {\n  results: any;\n  onRegenerate?: () => Promise<void>;\n}\n\nexport default function RiskTimelineView({ results, onRegenerate }: RiskTimelineViewProps) {\n  const [isRegenerating, setIsRegenerating] = useState(false);\n  const timeline = results?.timeline;\n  \n  const handleRegenerate = async () => {\n    if (!onRegenerate) return;\n    setIsRegenerating(true);\n    try {\n      await onRegenerate();\n    } catch (error) {\n      // Error handled by onRegenerate\n    } finally {\n      setIsRegenerating(false);\n    }\n  };\n  \n  if (!timeline) {\n    const hasIssues = results?.analysis?.issues?.length > 0;\n    return (\n      <div className=\"mt-4\">\n        <h3 className=\"text-xl font-semibold mb-4 text-white\">Risk Timeline</h3>\n        <div className=\"bg-yellow-900/20 border border-[#2f0012] rounded-lg p-4\">\n          <p className=\"text-yellow-200 mb-2\"> No timeline data available.</p>\n          <p className=\"text-sm text-gray-400 mb-4\">\n            {hasIssues ? (\n              <>\n                Issues were found but timeline generation failed. This may happen if:\n                <ul className=\"list-disc list-inside mt-2 space-y-1\">\n                  <li>API quota was exceeded (check console for details)</li>\n                  <li>An error occurred during generation</li>\n                </ul>\n              </>\n            ) : (\n              <>\n                No issues were found in the codebase, so no timeline can be generated.\n              </>\n            )}\n            <p className=\"mt-2\">Please check the browser console for details.</p>\n          </p>\n          {hasIssues && onRegenerate && (\n            <button\n              onClick={handleRegenerate}\n              disabled={isRegenerating}\n              className=\"bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg text-sm font-medium disabled:bg-gray-800 disabled:cursor-not-allowed transition-colors\"\n            >\n              {isRegenerating ? 'Regenerating...' : 'Regenerate Timeline'}\n            </button>\n          )}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"mt-4\">\n      <h3 className=\"text-xl font-semibold mb-4 text-white\">Risk Timeline</h3>\n      \n      {timeline.summary && <SummaryCards summary={timeline.summary} />}\n\n      {timeline.critical?.length > 0 && (\n        <IssueGroup title=\" Critical - Fix Now\" items={timeline.critical} color=\"red\" />\n      )}\n\n      {timeline.high?.length > 0 && (\n        <IssueGroup title=\" High - Fix Soon\" items={timeline.high} color=\"orange\" />\n      )}\n\n      {timeline.medium?.length > 0 && (\n        <IssueGroup title=\" Medium - Can Wait\" items={timeline.medium} color=\"yellow\" />\n      )}\n\n      {timeline.low?.length > 0 && (\n        <IssueGroup title=\" Low - Nice to Have\" items={timeline.low} color=\"gray\" />\n      )}\n\n      {timeline.recommendations?.length > 0 && (\n        <RecommendationsSection recommendations={timeline.recommendations} />\n      )}\n\n      {!timeline.critical?.length && !timeline.high?.length && !timeline.medium?.length && !timeline.low?.length && (\n        <p className=\"text-gray-400\">No issues categorized in timeline.</p>\n      )}\n    </div>\n  );\n}\n\nfunction SummaryCards({ summary }: { summary: any }) {\n  if (!summary) return null;\n  \n  const cards = [\n    { label: 'Fix Now', value: summary.fixNow || 0, color: 'red' },\n    { label: 'Fix Soon', value: summary.fixSoon || 0, color: 'orange' },\n    { label: 'Can Wait', value: summary.canWait || 0, color: 'yellow' },\n    { label: 'Nice to Have', value: summary.niceToHave || 0, color: 'gray' }\n  ];\n\n  return (\n    <div className=\"grid grid-cols-4 gap-4 mb-6\">\n      {cards.map(card => (\n        <div key={card.label} className={`bg-${card.color}-900/20 border border-${card.color}-800 p-4 rounded-lg`}>\n          <p className=\"text-sm text-gray-400 mb-1\">{card.label}</p>\n          <p className={`text-2xl font-bold text-${card.color}-400`}>{card.value}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nfunction IssueGroup({ title, items, color }: { title: string; items: any[]; color: string }) {\n  const colorClasses: Record<string, { border: string; bg: string; text: string }> = {\n    red: { border: 'border-red-500', bg: 'bg-red-900/20', text: 'text-red-400' },\n    orange: { border: 'border-orange-500', bg: 'bg-orange-900/20', text: 'text-orange-400' },\n    yellow: { border: 'border-yellow-500', bg: 'bg-yellow-900/20', text: 'text-yellow-400' },\n    gray: { border: 'border-gray-500', bg: 'bg-gray-800/50', text: 'text-gray-400' }\n  };\n\n  const classes = colorClasses[color] || colorClasses.gray;\n\n  return (\n    <div className=\"mb-4\">\n      <h4 className={`text-lg font-semibold ${classes.text} mb-2`}>{title}</h4>\n      {items.map((item: any, index: number) => (\n        <div key={index} className={`border-l-4 ${classes.border} p-3 mb-2 ${classes.bg} rounded-lg`}>\n          <p className=\"font-semibold text-white\">{item.issue?.type || 'Unknown'} - {item.issue?.file || 'Unknown file'}</p>\n          <p className=\"text-sm text-gray-300 mt-1\">{item.issue?.description || item.description || 'No description'}</p>\n          {item.timeline && <p className=\"text-sm text-gray-400 mt-1\"> {item.timeline}</p>}\n          {item.impact && <p className=\"text-sm text-gray-400\">Impact: {item.impact}</p>}\n        </div>\n      ))}\n    </div>\n  );\n}\n\nfunction RecommendationsSection({ recommendations }: { recommendations: string[] }) {\n  return (\n    <div className=\"mt-4 bg-blue-900/20 p-4 rounded-lg border border-[#2f0012]\">\n      <h4 className=\"font-semibold text-blue-300 mb-2\"> Recommendations</h4>\n      <ul className=\"list-disc list-inside space-y-1\">\n        {recommendations.map((rec: string, index: number) => (\n          <li key={index} className=\"text-sm text-gray-300\">{rec}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/Sidebar.tsx",
        "content": "'use client';\n\nimport { useState, useEffect } from 'react';\nimport Image from 'next/image';\nimport { getSessions, deleteSession, type Session } from '@/lib/services/sessionStorage';\n\ninterface SidebarProps {\n  isOpen: boolean;\n  onToggle: () => void;\n  onLoadSession?: (session: Session) => void;\n  isMobile?: boolean;\n}\n\nexport default function Sidebar({ isOpen, onToggle, onLoadSession, isMobile = false }: SidebarProps) {\n  const [isSessionsOpen, setIsSessionsOpen] = useState(true);\n  const [isHovering, setIsHovering] = useState(false);\n  const [sessions, setSessions] = useState<Session[]>([]);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  useEffect(() => {\n    loadSessions();\n    // Refresh sessions every 5 seconds\n    const interval = setInterval(loadSessions, 5000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const loadSessions = async () => {\n    try {\n      const allSessions = await getSessions();\n      setSessions(allSessions);\n    } catch (error) {\n      console.error('Failed to load sessions:', error);\n    }\n  };\n\n  const handleDeleteSession = async (e: React.MouseEvent, sessionId: string) => {\n    e.stopPropagation();\n    try {\n      await deleteSession(sessionId);\n      await loadSessions();\n    } catch (error) {\n      console.error('Failed to delete session:', error);\n    }\n  };\n\n  const handleLoadSession = (session: Session) => {\n    onLoadSession?.(session);\n  };\n\n  const filteredSessions = sessions.filter(session =>\n    session.name.toLowerCase().includes(searchQuery.toLowerCase()) ||\n    session.repoUrl?.toLowerCase().includes(searchQuery.toLowerCase())\n  );\n\n  const formatDate = (timestamp: number) => {\n    const date = new Date(timestamp);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffMins = Math.floor(diffMs / 60000);\n    const diffHours = Math.floor(diffMs / 3600000);\n    const diffDays = Math.floor(diffMs / 86400000);\n\n    if (diffMins < 1) return 'Just now';\n    if (diffMins < 60) return `${diffMins}m ago`;\n    if (diffHours < 24) return `${diffHours}h ago`;\n    if (diffDays < 7) return `${diffDays}d ago`;\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <div \n      className={`bg-[#0f0f0f] text-white h-screen flex flex-col fixed left-0 top-0 z-20 border-r border-[#2f0012] transition-all duration-300 ${\n        isMobile \n          ? (isOpen ? 'w-64' : '-translate-x-full w-64')\n          : (isOpen ? 'w-64' : 'w-16')\n      }`}\n      onMouseEnter={() => !isMobile && setIsHovering(true)}\n      onMouseLeave={() => !isMobile && setIsHovering(false)}\n    >\n      {/* Logo & Toggle */}\n      <div className=\"p-4 flex items-center justify-start\">\n        <button\n          onClick={onToggle}\n          className=\"flex items-center gap-2 transition-all duration-300 hover:opacity-80\"\n        >\n          {isOpen ? (\n            <>\n              {isHovering ? (\n                // Show close panel icon when open and hovering\n                <svg className=\"w-6 h-6 text-white flex-shrink-0\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\" strokeWidth={2}>\n                  <rect x=\"3\" y=\"4\" width=\"8\" height=\"16\" rx=\"1\" />\n                  <rect x=\"13\" y=\"4\" width=\"8\" height=\"16\" rx=\"1\" />\n                </svg>\n              ) : (\n                // Show app icon when open\n                <Image src=\"/icon.png\" alt=\"Shels\" width={24} height={24} className=\"w-6 h-6 flex-shrink-0\" />\n              )}\n              <span className=\"text-xl font-semibold whitespace-nowrap\">Shels</span>\n            </>\n          ) : (\n            // Show icon or open panel icon when closed and hovering\n            isHovering ? (\n              <svg className=\"w-6 h-6 text-white flex-shrink-0\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\" strokeWidth={2}>\n                <rect x=\"3\" y=\"4\" width=\"8\" height=\"16\" rx=\"1\" />\n                <path d=\"M13 8l4-4 4 4\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n                <path d=\"M17 8v12\" />\n              </svg>\n            ) : (\n              <Image src=\"/icon.png\" alt=\"Shels\" width={24} height={24} className=\"w-6 h-6 flex-shrink-0\" />\n            )\n          )}\n        </button>\n      </div>\n\n      {/* Search */}\n      <div className={`p-4 transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 h-0 p-0 overflow-hidden'}`}>\n        <div className=\"relative\">\n          <input\n            type=\"text\"\n            placeholder=\"Search for repo or sessions\"\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            className=\"w-full bg-[#1f1f1f] text-white px-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-gray-600\"\n          />\n          <svg className=\"absolute right-3 top-2.5 w-5 h-5 text-gray-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n          </svg>\n        </div>\n      </div>\n\n      {/* Recent Sessions */}\n      <div className={`flex-1 overflow-y-auto p-4 transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 h-0 p-0 overflow-hidden'}`}>\n        <button\n          onClick={() => setIsSessionsOpen(!isSessionsOpen)}\n          className=\"w-full flex items-center justify-between text-gray-400 hover:text-white mb-2\"\n        >\n          <span className=\"text-sm font-medium\">Recent sessions</span>\n          <svg className={`w-4 h-4 transition-transform ${isSessionsOpen ? 'rotate-180' : ''}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 15l7-7 7 7\" />\n          </svg>\n        </button>\n        \n        {isSessionsOpen && (\n          <div className=\"mt-2 space-y-1\">\n            {filteredSessions.length === 0 ? (\n              <div className=\"bg-[#1f1f1f] rounded-lg p-4\">\n                <div className=\"flex items-center gap-2 text-gray-500\">\n                  <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2\" />\n                  </svg>\n                  <span className=\"text-sm\">\n                    {searchQuery ? 'No sessions found' : 'Recent sessions will show up here'}\n                  </span>\n                </div>\n              </div>\n            ) : (\n              filteredSessions.map((session) => (\n                <div\n                  key={session.id}\n                  onClick={() => handleLoadSession(session)}\n                  className=\"bg-[#1f1f1f] hover:bg-[#2a2a2a] rounded-lg p-3 cursor-pointer transition-colors group\"\n                >\n                  <div className=\"flex items-start justify-between gap-2\">\n                    <div className=\"flex-1 min-w-0\">\n                      <p className=\"text-sm font-medium text-white truncate\">{session.name}</p>\n                      <p className=\"text-xs text-gray-500 mt-1\">{formatDate(session.timestamp)}</p>\n                      {session.repoUrl && (\n                        <p className=\"text-xs text-gray-600 mt-1 truncate\">{session.repoUrl}</p>\n                      )}\n                    </div>\n                    <button\n                      onClick={(e) => handleDeleteSession(e, session.id)}\n                      className=\"opacity-0 group-hover:opacity-100 transition-opacity text-gray-500 hover:text-red-400 p-1\"\n                      title=\"Delete session\"\n                    >\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                      </svg>\n                    </button>\n                  </div>\n                </div>\n              ))\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Connect to GitHub */}\n      <div className={`p-4 transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 h-0 p-0 overflow-hidden'}`}>\n        <button className=\"w-full bg-[#1f1f1f] hover:bg-[#2a2a2a] text-white px-4 py-2 rounded-lg flex items-center gap-2 justify-center transition-colors\">\n          <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path d=\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"/>\n          </svg>\n          <span className=\"text-sm font-medium\">Connect to GitHub</span>\n        </button>\n      </div>\n\n      {/* Bottom Actions - Always Visible */}\n      <div className=\"p-4 space-y-3\">\n        {/* Settings */}\n        <button \n          className={`w-full flex items-center gap-3 text-gray-500 hover:text-white transition-colors px-2 py-2 rounded-lg hover:bg-[#1f1f1f] ${isOpen ? 'justify-start' : 'justify-center'}`}\n          title=\"Settings\"\n        >\n          <svg className=\"w-5 h-5 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n          </svg>\n          {isOpen && <span className=\"text-sm\">Settings</span>}\n        </button>\n\n        {/* Profile */}\n        <button \n          className={`w-full flex items-center gap-3 text-gray-500 hover:text-white transition-colors px-2 py-2 rounded-lg hover:bg-[#1f1f1f] ${isOpen ? 'justify-start' : 'justify-center'}`}\n          title=\"Profile\"\n        >\n          <div className=\"w-8 h-8 rounded-full bg-[#1f1f1f] hover:bg-[#2a2a2a] flex items-center justify-center transition-colors flex-shrink-0\">\n            <svg className=\"w-5 h-5 text-gray-400\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path d=\"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\"/>\n            </svg>\n          </div>\n          {isOpen && <span className=\"text-sm\">Profile</span>}\n        </button>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "components/TestConfig.tsx",
        "content": "'use client';\n\ninterface TestConfigProps {\n  testTypes: ('unit' | 'integration' | 'security' | 'performance')[];\n  duration: 'one-time' | 'continuous';\n  autoFix: boolean;\n  onTestTypeChange: (type: 'unit' | 'integration' | 'security' | 'performance') => void;\n  onDurationChange: (duration: 'one-time' | 'continuous') => void;\n  onAutoFixChange: (autoFix: boolean) => void;\n}\n\nexport default function TestConfig({\n  testTypes,\n  duration,\n  autoFix,\n  onTestTypeChange,\n  onDurationChange,\n  onAutoFixChange\n}: TestConfigProps) {\n  return (\n    <div className=\"bg-[#171717] border border-[#2f0012] rounded-lg p-6 mb-6\">\n      <h2 className=\"text-xl font-semibold mb-4 text-white\">Test Configuration</h2>\n      \n      <div className=\"mb-4\">\n        <label className=\"block text-sm font-medium mb-2 text-gray-400\">Test Types</label>\n        <div className=\"grid grid-cols-2 gap-3\">\n          {(['unit', 'integration', 'security', 'performance'] as const).map(type => (\n            <label key={type} className=\"flex items-center text-gray-300 cursor-pointer hover:text-white\">\n              <input\n                type=\"checkbox\"\n                checked={testTypes.includes(type)}\n                onChange={() => onTestTypeChange(type)}\n                className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] rounded focus:ring-gray-700\"\n              />\n              {type.charAt(0).toUpperCase() + type.slice(1)} Tests\n            </label>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"mb-4\">\n        <label className=\"block text-sm font-medium mb-2 text-gray-400\">Duration</label>\n        <div className=\"space-y-2\">\n          <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white\">\n            <input\n              type=\"radio\"\n              name=\"duration\"\n              value=\"one-time\"\n              checked={duration === 'one-time'}\n              onChange={() => onDurationChange('one-time')}\n              className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] focus:ring-gray-700\"\n            />\n            One-time test (run once)\n          </label>\n          <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white\">\n            <input\n              type=\"radio\"\n              name=\"duration\"\n              value=\"continuous\"\n              checked={duration === 'continuous'}\n              onChange={() => onDurationChange('continuous')}\n              className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] focus:ring-gray-700\"\n            />\n            Continuous monitoring (24/7)\n          </label>\n        </div>\n      </div>\n\n      <div>\n        <label className=\"flex items-center text-gray-300 cursor-pointer hover:text-white\">\n          <input\n            type=\"checkbox\"\n            checked={autoFix}\n            onChange={(e) => onAutoFixChange(e.target.checked)}\n            className=\"mr-2 w-4 h-4 text-gray-600 bg-[#1f1f1f] border-[#2f0012] rounded focus:ring-gray-700\"\n          />\n          Enable automatic fixes\n        </label>\n      </div>\n    </div>\n  );\n}\n",
        "language": "typescript"
      },
      {
        "path": "hooks/useCodeTesting.ts",
        "content": "import { useState } from 'react';\nimport { apiFetch } from '@/lib/utils/fetchHelper';\nimport { saveSession } from '@/lib/services/sessionStorage';\n\nexport function useCodeTesting() {\n  const [errorCallback, setErrorCallback] = useState<((error: { message: string; type?: 'error' | 'warning' | 'info' }) => void) | null>(null);\n  const [repoUrl, setRepoUrl] = useState('');\n  const [files, setFiles] = useState<File[]>([]);\n  const [testTypes, setTestTypes] = useState<('unit' | 'integration' | 'security' | 'performance')[]>(['unit', 'integration', 'security']);\n  const [duration, setDuration] = useState<'one-time' | 'continuous'>('one-time');\n  const [autoFix, setAutoFix] = useState(true);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [results, setResults] = useState<any>(null);\n  const [progress, setProgress] = useState({ step: '', percentage: 0 });\n  const [marathonTaskId, setMarathonTaskId] = useState<string | null>(null);\n  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);\n\n  const handleTestTypeChange = (type: 'unit' | 'integration' | 'security' | 'performance') => {\n    setTestTypes(prev => prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]);\n  };\n\n  const handleQuotaError = () => {\n    const message = 'API quota exceeded. The free tier allows 20 requests per day. Please wait or use a different API key.';\n    errorCallback?.({ message, type: 'warning' });\n    setIsAnalyzing(false);\n  };\n\n  const handleStartTesting = async () => {\n    if (!repoUrl && files.length === 0) {\n      errorCallback?.({ message: 'Please provide either a GitHub URL or upload files', type: 'warning' });\n      return;\n    }\n\n    setIsAnalyzing(true);\n    setResults(null);\n    setProgress({ step: 'Reading repository...', percentage: 10 });\n\n    try {\n      const analyzeData = await performAnalysis();\n      const testData = await generateTests(analyzeData);\n      const testResults = await runTests(testData);\n      const fixes = await generateFixes(analyzeData);\n      \n      // Generate insights with better error handling\n      setProgress({ step: 'Generating insights...', percentage: 90 });\n      \n      // Generate timeline and metrics in parallel (but don't fail if one fails)\n      const [timeline, metrics] = await Promise.allSettled([\n        generateRiskTimeline(analyzeData),\n        generateCodeMetrics(analyzeData)\n      ]);\n      \n      const timelineResult = timeline.status === 'fulfilled' ? timeline.value : null;\n      const metricsResult = metrics.status === 'fulfilled' ? metrics.value : null;\n      \n      const marathonTask = await startMarathonIfNeeded(analyzeData);\n\n      const finalResults: any = {\n        analysis: analyzeData.analysis,\n        tests: testData.tests,\n        testResults,\n        fixes,\n        marathonTask,\n        timeline: timelineResult,\n        metrics: metricsResult,\n        files: analyzeData.files || [],\n        issueData: {}\n      };\n\n      setResults(finalResults);\n\n      // Save session automatically\n      try {\n        const sessionName = repoUrl \n          ? `Analysis: ${repoUrl.split('/').pop() || 'Repository'}`\n          : `Analysis: ${files.length} files`;\n        \n        const savedSession = await saveSession({\n          name: sessionName,\n          repoUrl: repoUrl || undefined,\n          results: finalResults,\n          config: {\n            testTypes,\n            duration,\n            autoFix\n          }\n        });\n        \n        setCurrentSessionId(savedSession.id);\n      } catch (error) {\n        console.error('Failed to save session:', error);\n      }\n\n      setProgress({ step: 'Complete!', percentage: 100 });\n    } catch (error: any) {\n      // Don't show error if it's QUOTA_EXCEEDED (already handled)\n      if (error.message !== 'QUOTA_EXCEEDED') {\n        handleError(error);\n      }\n    } finally {\n      setIsAnalyzing(false);\n    }\n  };\n\n  async function performAnalysis() {\n    setProgress({ step: 'Analyzing codebase...', percentage: 30 });\n    const formData = new FormData();\n    if (repoUrl) formData.append('repoUrl', repoUrl);\n    else files.forEach(file => formData.append('files', file));\n\n    const response = await fetch('/api/analyze', { method: 'POST', body: formData });\n    const data = await response.json();\n    \n    if (!data.success) {\n      let errorObj;\n      try {\n        errorObj = typeof data.message === 'string' ? JSON.parse(data.message) : data.message;\n      } catch {\n        errorObj = { error: { code: 500, status: 'UNKNOWN' } };\n      }\n      \n      if (errorObj.error?.code === 429 || errorObj.error?.status === 'RESOURCE_EXHAUSTED') {\n        handleQuotaError();\n        throw new Error('QUOTA_EXCEEDED');\n      }\n      throw new Error(data.message || 'Analysis failed');\n    }\n    return data;\n  }\n\n  async function generateTests(analyzeData: any) {\n    setProgress({ step: 'Generating tests...', percentage: 50 });\n    const data = await apiFetch('/api/generate-tests', {\n      method: 'POST',\n      body: JSON.stringify({ repoUrl: repoUrl || null, files: analyzeData.files || [], testTypes })\n    });\n    if (!data.success) throw new Error(data.message || 'Failed to generate tests');\n    return data;\n  }\n\n  async function runTests(testData: any) {\n    setProgress({ step: 'Running tests...', percentage: 70 });\n    const allTests = [\n      ...(testData.tests?.unitTests || []),\n      ...(testData.tests?.integrationTests || []),\n      ...(testData.tests?.securityTests || []),\n      ...(testData.tests?.performanceTests || [])\n    ];\n    if (allTests.length === 0) return null;\n\n    const data = await apiFetch('/api/run-tests', {\n      method: 'POST',\n      body: JSON.stringify({ tests: allTests })\n    });\n    return data.success ? data.results : null;\n  }\n\n  async function generateFixes(analyzeData: any) {\n    setProgress({ step: 'Generating fixes...', percentage: 85 });\n    if (!autoFix || !analyzeData.analysis?.issues || analyzeData.analysis.issues.length === 0) return null;\n\n    const filesForFix = (analyzeData.files || []).filter((file: any) => \n      analyzeData.analysis.issues.some((issue: any) => issue.file === file.path)\n    );\n    if (filesForFix.length === 0) return null;\n\n    const data = await apiFetch('/api/fix', {\n      method: 'POST',\n      body: JSON.stringify({ files: filesForFix, issues: analyzeData.analysis.issues })\n    });\n    return data.success ? data.fixes : null;\n  }\n\n  async function startMarathonIfNeeded(analyzeData: any) {\n    if (duration !== 'continuous') return null;\n    const data = await apiFetch('/api/marathon', {\n      method: 'POST',\n      body: JSON.stringify({\n        action: 'start',\n        config: { repoUrl: repoUrl || 'uploaded', testInterval: 60, autoFix, notifyOnIssue: true }\n      })\n    });\n    if (data.success) {\n      setMarathonTaskId(data.taskId);\n      return data.status;\n    }\n    return null;\n  }\n\n  function handleError(error: any) {\n    let errorMessage = error.message || 'An error occurred';\n    \n    // Skip if it's QUOTA_EXCEEDED (already handled)\n    if (errorMessage === 'QUOTA_EXCEEDED') {\n      return;\n    }\n    \n    try {\n      const errorObj = typeof errorMessage === 'string' ? JSON.parse(errorMessage) : errorMessage;\n      if (errorObj.error?.code === 429 || errorObj.error?.status === 'RESOURCE_EXHAUSTED') {\n        handleQuotaError();\n        return;\n      }\n      if (errorObj.error?.message) errorMessage = errorObj.error.message;\n    } catch {\n      // If parsing fails, use original message\n    }\n    \n    if (errorMessage.includes('quota') || errorMessage.includes('429') || errorMessage.includes('RESOURCE_EXHAUSTED')) {\n      handleQuotaError();\n    } else {\n      errorCallback?.({ message: errorMessage, type: 'error' });\n    }\n  }\n\n  async function generateRiskTimeline(analyzeData: any) {\n    try {\n      if (!analyzeData.analysis?.issues || analyzeData.analysis.issues.length === 0) {\n        return null;\n      }\n\n      const data = await apiFetch('/api/risk-timeline', {\n        method: 'POST',\n        body: JSON.stringify({\n          issues: analyzeData.analysis.issues,\n          codebaseContext: analyzeData.files?.map((f: any) => f.content).join('\\n\\n') || ''\n        })\n      });\n      \n      if (data.success && data.timeline) {\n        return data.timeline;\n      }\n      \n      const errorMsg = data.message || 'Unknown error';\n      if (errorMsg.includes('quota') || errorMsg.includes('429') || errorMsg.includes('RESOURCE_EXHAUSTED')) {\n        errorCallback?.({ \n          message: 'Risk Timeline generation skipped due to API quota limit', \n          type: 'warning' \n        });\n      }\n      return null;\n    } catch (error: any) {\n      const errorMsg = error.message || 'Failed to generate risk timeline';\n      if (!errorMsg.includes('quota') && !errorMsg.includes('429')) {\n        errorCallback?.({ \n          message: `Risk Timeline: ${errorMsg}`, \n          type: 'warning' \n        });\n      }\n      return null;\n    }\n  }\n\n  async function generateCodeMetrics(analyzeData: any) {\n    try {\n      if (!analyzeData.files || analyzeData.files.length === 0) {\n        return null;\n      }\n\n      const data = await apiFetch('/api/code-metrics', {\n        method: 'POST',\n        body: JSON.stringify({\n          files: analyzeData.files || [],\n          issues: analyzeData.analysis?.issues || []\n        })\n      });\n      \n      if (data.success && data.metrics) {\n        return data.metrics;\n      }\n      \n      const errorMsg = data.message || 'Unknown error';\n      if (errorMsg.includes('quota') || errorMsg.includes('429') || errorMsg.includes('RESOURCE_EXHAUSTED')) {\n        errorCallback?.({ \n          message: 'Code Metrics generation skipped due to API quota limit', \n          type: 'warning' \n        });\n      }\n      return null;\n    } catch (error: any) {\n      const errorMsg = error.message || 'Failed to calculate code metrics';\n      if (!errorMsg.includes('quota') && !errorMsg.includes('429')) {\n        errorCallback?.({ \n          message: `Code Metrics: ${errorMsg}`, \n          type: 'warning' \n        });\n      }\n      return null;\n    }\n  }\n\n  const regenerateTimeline = async () => {\n    if (!results?.analysis) {\n      errorCallback?.({ message: 'No analysis data available', type: 'warning' });\n      return;\n    }\n    \n    try {\n      const timeline = await generateRiskTimeline({\n        analysis: results.analysis,\n        files: results.files || []\n      });\n      \n      if (timeline) {\n        setResults((prev: any) => ({ ...prev, timeline }));\n        \n        // Save to session\n        if (currentSessionId) {\n          try {\n            await fetch(`/api/sessions/${currentSessionId}`, {\n              method: 'PATCH',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ \n                results: { ...results, timeline }\n              })\n            });\n          } catch (error) {\n            console.error('Failed to save timeline to session:', error);\n          }\n        }\n        \n        errorCallback?.({ message: 'Risk Timeline regenerated successfully', type: 'info' });\n      }\n    } catch (error: any) {\n      errorCallback?.({ message: 'Failed to regenerate timeline', type: 'error' });\n    }\n  };\n\n  const regenerateMetrics = async () => {\n    if (!results?.files || results.files.length === 0) {\n      errorCallback?.({ message: 'No files data available', type: 'warning' });\n      return;\n    }\n    \n    try {\n      const metrics = await generateCodeMetrics({\n        files: results.files || [],\n        analysis: results.analysis || { issues: [] }\n      });\n      \n      if (metrics) {\n        setResults((prev: any) => ({ ...prev, metrics }));\n        \n        // Save to session\n        if (currentSessionId) {\n          try {\n            await fetch(`/api/sessions/${currentSessionId}`, {\n              method: 'PATCH',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ \n                results: { ...results, metrics }\n              })\n            });\n          } catch (error) {\n            console.error('Failed to save metrics to session:', error);\n          }\n        }\n        \n        errorCallback?.({ message: 'Code Metrics regenerated successfully', type: 'info' });\n      }\n    } catch (error: any) {\n      errorCallback?.({ message: 'Failed to regenerate metrics', type: 'error' });\n    }\n  };\n\n  const loadSession = (session: any) => {\n    setResults(session.results);\n    setCurrentSessionId(session.id);\n    setRepoUrl(session.repoUrl || '');\n    setTestTypes(session.config.testTypes || ['unit', 'integration', 'security']);\n    setDuration(session.config.duration || 'one-time');\n    setAutoFix(session.config.autoFix ?? true);\n    errorCallback?.({ message: `Session \"${session.name}\" loaded successfully`, type: 'info' });\n  };\n\n  return {\n    repoUrl, files, testTypes, duration, autoFix, isAnalyzing, results, progress, marathonTaskId, currentSessionId,\n    setRepoUrl, setFiles, handleTestTypeChange, setDuration, setAutoFix, handleStartTesting,\n    setMarathonTaskId, setErrorCallback, regenerateTimeline, regenerateMetrics, loadSession\n  };\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/autoFix.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface CodeFix {\n  issue: CodeIssue;\n  fixedCode: string;\n  explanation: string;\n  confidence: 'high' | 'medium' | 'low';\n}\n\n/**\n * Generate fix for a code issue\n */\nexport async function generateFix(\n  filePath: string,\n  fileContent: string,\n  issue: CodeIssue\n): Promise<CodeFix> {\n  try {\n    const prompt = `Fix this code issue:\n\nFile: ${filePath}\nIssue Type: ${issue.type}\nSeverity: ${issue.severity}\nDescription: ${issue.description}\nSuggestion: ${issue.suggestion || 'None'}\n\nOriginal Code:\n${fileContent}\n\nProvide the fixed code with:\n1. Complete fixed code for the file\n2. Explanation of what was fixed\n3. Confidence level (high/medium/low)\n\nReturn ONLY valid JSON:\n{\n  \"fixedCode\": \"complete fixed code here\",\n  \"explanation\": \"what was fixed and why\",\n  \"confidence\": \"high\"\n}`;\n\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    return {\n      issue,\n      fixedCode: data.fixedCode,\n      explanation: data.explanation,\n      confidence: data.confidence || 'medium'\n    };\n  } catch (error) {\n    console.error('Error generating fix:', error);\n    throw error;\n  }\n}\n\n/**\n * Generate fixes for multiple issues\n */\nexport async function generateFixes(\n  files: Array<{ path: string; content: string }>,\n  issues: CodeIssue[]\n): Promise<CodeFix[]> {\n  const fixes: CodeFix[] = [];\n\n  // Group issues by file\n  const issuesByFile = new Map<string, CodeIssue[]>();\n  issues.forEach(issue => {\n    if (!issuesByFile.has(issue.file)) {\n      issuesByFile.set(issue.file, []);\n    }\n    issuesByFile.get(issue.file)!.push(issue);\n  });\n\n  // Generate fix for each file\n  for (const [filePath, fileIssues] of issuesByFile) {\n    const file = files.find(f => f.path === filePath);\n    if (!file) continue;\n\n    // Fix all issues in the file at once\n    try {\n      const prompt = `Fix all these issues in this file:\n\nFile: ${filePath}\nIssues:\n${fileIssues.map((issue, i) => \n  `${i + 1}. ${issue.type} (${issue.severity}): ${issue.description}`\n).join('\\n')}\n\nOriginal Code:\n${file.content}\n\nProvide the complete fixed code that addresses all issues.\n\nReturn ONLY valid JSON:\n{\n  \"fixedCode\": \"complete fixed code here\",\n  \"explanation\": \"what was fixed and why\",\n  \"confidence\": \"high\"\n}`;\n\n      const result = await generateContentWithFallback(prompt);\n      const text = result.text || '';\n\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const data = JSON.parse(jsonMatch[0]);\n        \n        fileIssues.forEach(issue => {\n          fixes.push({\n            issue,\n            fixedCode: data.fixedCode,\n            explanation: data.explanation,\n            confidence: data.confidence || 'medium'\n          });\n        });\n      }\n    } catch (error) {\n      console.error(`Error fixing file ${filePath}:`, error);\n    }\n  }\n\n  return fixes;\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/businessImpact.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface BusinessImpact {\n  issueId: string;\n  estimatedCost?: {\n    revenue?: string;\n    users?: string;\n    time?: string;\n    reputation?: string;\n  };\n  businessMetrics?: {\n    conversion?: string;\n    seo?: string;\n    security?: string;\n    performance?: string;\n  };\n  impactScore: number; // 0-100\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  explanation: string;\n  realWorldExample?: string;\n}\n\nconst BUSINESS_IMPACT_PROMPT = `Analyze the business impact of this code issue. Think like a CTO or Product Manager, not just a developer.\n\nIssue Details:\n- Type: {ISSUE_TYPE}\n- Severity: {SEVERITY}\n- File: {FILE}\n- Description: {DESCRIPTION}\n- Context: {CONTEXT}\n\nAnalyze and provide:\n1. **Estimated Cost Impact**: \n   - Revenue loss (if applicable)\n   - User impact (churn, bounce rate)\n   - Time wasted\n   - Reputation damage\n\n2. **Business Metrics Affected**:\n   - Conversion rate impact\n   - SEO ranking impact\n   - Security posture\n   - Performance metrics\n\n3. **Impact Score** (0-100): How critical is this for business?\n\n4. **Real-world Example**: A concrete scenario showing the impact\n\n5. **Priority**: critical/high/medium/low based on business impact, not just technical severity\n\nReturn ONLY valid JSON:\n{\n  \"estimatedCost\": {\n    \"revenue\": \"e.g., '30% lead loss' or 'N/A'\",\n    \"users\": \"e.g., '5% bounce rate increase' or 'N/A'\",\n    \"time\": \"e.g., '2 hours/week debugging' or 'N/A'\",\n    \"reputation\": \"e.g., 'Security breach risk' or 'N/A'\"\n  },\n  \"businessMetrics\": {\n    \"conversion\": \"e.g., '15% drop in form submissions' or 'N/A'\",\n    \"seo\": \"e.g., 'Page speed penalty' or 'N/A'\",\n    \"security\": \"e.g., 'XSS attack vector' or 'N/A'\",\n    \"performance\": \"e.g., '500ms delay per request' or 'N/A'\"\n  },\n  \"impactScore\": 85,\n  \"priority\": \"critical\",\n  \"explanation\": \"Clear explanation of business impact in 2-3 sentences\",\n  \"realWorldExample\": \"Concrete scenario: 'If an attacker exploits this XSS vulnerability, they could steal user session cookies, leading to account takeovers and potential data breach affecting 10,000+ users.'\"\n}`;\n\nexport async function analyzeBusinessImpact(\n  issue: CodeIssue,\n  codebaseContext?: string\n): Promise<BusinessImpact> {\n  try {\n    const prompt = BUSINESS_IMPACT_PROMPT\n      .replace('{ISSUE_TYPE}', issue.type)\n      .replace('{SEVERITY}', issue.severity)\n      .replace('{FILE}', issue.file)\n      .replace('{DESCRIPTION}', issue.description)\n      .replace('{CONTEXT}', codebaseContext || 'No additional context available');\n\n    const response = await generateContentWithFallback(prompt);\n    const text = response.text || '';\n    \n    // Extract JSON from response\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const impact: BusinessImpact = JSON.parse(jsonMatch[0]);\n    \n    // Add issueId\n    impact.issueId = `${issue.file}-${issue.type}-${issue.severity}`;\n    \n    return impact;\n  } catch (error: any) {\n    console.error('Error analyzing business impact:', error);\n    \n    // Fallback: basic impact based on severity\n    const fallbackScore = issue.severity === 'high' ? 75 : issue.severity === 'medium' ? 50 : 25;\n    const fallbackPriority = issue.severity === 'high' ? 'high' : issue.severity === 'medium' ? 'medium' : 'low';\n    \n    return {\n      issueId: `${issue.file}-${issue.type}-${issue.severity}`,\n      impactScore: fallbackScore,\n      priority: fallbackPriority as 'critical' | 'high' | 'medium' | 'low',\n      explanation: `This ${issue.severity} severity ${issue.type} issue could impact user experience and system reliability.`,\n      estimatedCost: {},\n      businessMetrics: {}\n    };\n  }\n}\n\nexport async function analyzeMultipleIssues(\n  issues: CodeIssue[],\n  codebaseContext?: string\n): Promise<BusinessImpact[]> {\n  const impacts = await Promise.all(\n    issues.map(issue => analyzeBusinessImpact(issue, codebaseContext))\n  );\n  \n  // Sort by impact score (highest first)\n  return impacts.sort((a, b) => b.impactScore - a.impactScore);\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/codeAnalyzer.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\n\nexport interface CodeFile {\n  path: string;\n  content: string;\n  language?: string;\n}\n\nexport interface CodeIssue {\n  type: 'bug' | 'security' | 'performance' | 'quality' | 'error_handling';\n  severity: 'high' | 'medium' | 'low';\n  file: string;\n  line?: number;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface CodeAnalysis {\n  totalFiles: number;\n  totalLines: number;\n  issues: CodeIssue[];\n  structure: {\n    mainFiles: string[];\n    dependencies: string[];\n    architecture: string;\n  };\n  summary: string;\n  totalRepoFiles?: number;\n  ignoredFiles?: number;\n  analysisScope?: {\n    analyzedFileTypes: string[];\n    ignoredFileTypes: string[];\n    focus: string;\n  };\n}\n\nconst ANALYSIS_PROMPT = `You are an expert code analyzer. Analyze this entire codebase and provide a comprehensive analysis.\n\nCodebase:\n{CODEBASE}\n\nAnalyze and find:\n1. **Bugs and Errors**: All programming bugs, logic errors, and potential runtime errors\n2. **Security Vulnerabilities**: SQL injection, XSS, authentication issues, authorization problems, insecure data handling\n3. **Performance Issues**: Slow algorithms, memory leaks, inefficient database queries, unnecessary re-renders\n4. **Code Quality Problems**: Code smells, duplicated code, complex functions, poor naming, missing comments\n5. **Missing Error Handling**: Functions without try-catch, missing null checks, unhandled edge cases\n\nFor each issue found, provide:\n- Type (bug/security/performance/quality/error_handling)\n- Severity (high/medium/low)\n- File path\n- Line number (if applicable)\n- Description\n- Suggestion for fix\n\nAlso analyze:\n- Project structure and architecture\n- Main files and their purposes\n- Dependencies and their usage\n- Overall code quality assessment\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"issues\": [\n    {\n      \"type\": \"bug\",\n      \"severity\": \"high\",\n      \"file\": \"app/api/users.ts\",\n      \"line\": 45,\n      \"description\": \"Null pointer exception possible when user is null\",\n      \"suggestion\": \"Add null check before accessing user properties\"\n    }\n  ],\n  \"structure\": {\n    \"mainFiles\": [\"app/page.tsx\", \"lib/api.ts\"],\n    \"dependencies\": [\"react\", \"next\"],\n    \"architecture\": \"Next.js app with API routes\"\n  },\n  \"summary\": \"Overall assessment of the codebase...\"\n}`;\n\nconst FILE_ANALYSIS_PROMPT = `Analyze this code file and find all issues:\n\nFile: {FILE_PATH}\nCode:\n{CODE}\n\nFind all bugs, security issues, performance problems, code quality issues, and missing error handling.\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"type\": \"bug\",\n    \"severity\": \"high\",\n    \"file\": \"{FILE_PATH}\",\n    \"line\": 45,\n    \"description\": \"Issue description\",\n    \"suggestion\": \"How to fix\"\n  }\n]`;\n\n/**\n * Analyze entire codebase using Extended Context (1M tokens)\n */\nexport async function analyzeCodebase(files: CodeFile[]): Promise<CodeAnalysis> {\n  try {\n    const codebaseContent = files\n      .map(file => `File: ${file.path}\\n${file.content}`)\n      .join('\\n\\n---\\n\\n');\n\n    const prompt = ANALYSIS_PROMPT.replace('{CODEBASE}', codebaseContent);\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    return {\n      totalFiles: files.length,\n      totalLines: files.reduce((sum, file) => sum + file.content.split('\\n').length, 0),\n      issues: data.issues || [],\n      structure: data.structure || {\n        mainFiles: [],\n        dependencies: [],\n        architecture: 'Unknown'\n      },\n      summary: data.summary || 'Analysis completed',\n      analysisScope: {\n        analyzedFileTypes: ['JavaScript', 'TypeScript', 'Python', 'Java', 'C++', 'C#', 'Go', 'Rust', 'PHP', 'Ruby', 'Swift', 'Kotlin'],\n        ignoredFileTypes: ['HTML', 'CSS', 'Images', 'Config files', 'Git files', 'Documentation'],\n        focus: 'Executable code with runtime risks'\n      }\n    };\n  } catch (error: any) {\n    console.error('Error analyzing codebase:', error);\n    \n    if (error.message?.includes('429') || error.message?.includes('quota') || error.message?.includes('RESOURCE_EXHAUSTED')) {\n      const quotaError = {\n        error: {\n          code: 429,\n          message: 'API quota exceeded. Please wait or use a different API key.',\n          status: 'RESOURCE_EXHAUSTED'\n        }\n      };\n      throw new Error(JSON.stringify(quotaError));\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * Analyze single file\n */\nexport async function analyzeFile(file: CodeFile): Promise<CodeIssue[]> {\n  try {\n    const prompt = FILE_ANALYSIS_PROMPT\n      .replace('{FILE_PATH}', file.path)\n      .replace('{CODE}', file.content);\n\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) {\n      return [];\n    }\n\n    return JSON.parse(jsonMatch[0]);\n  } catch (error) {\n    console.error('Error analyzing file:', error);\n    return [];\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/codeMetrics.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeFile, CodeIssue } from './codeAnalyzer';\n\nexport interface CodeMetrics {\n  maintainability: number; // 0-100\n  complexity: number; // 0-100 (higher = more complex)\n  testability: number; // 0-100\n  security: number; // 0-100\n  performance: number; // 0-100\n  overall: number; // 0-100\n  recommendations: string[];\n  trends: {\n    improvement: string[];\n    degradation: string[];\n  };\n}\n\n/**\n * Calculate comprehensive code metrics\n */\nexport async function calculateCodeMetrics(\n  files: CodeFile[],\n  issues: CodeIssue[]\n): Promise<CodeMetrics> {\n  const codebaseContent = files\n    .map(file => `File: ${file.path}\\n${file.content}`)\n    .join('\\n\\n---\\n\\n');\n\n  const prompt = `Analyze this codebase and calculate comprehensive metrics.\n\nCodebase:\n${codebaseContent}\n\nIssues Found: ${issues.length}\n${issues.map(i => `- ${i.type} (${i.severity}): ${i.description}`).join('\\n')}\n\nCalculate metrics (0-100 scale):\n\n1. **Maintainability**: How easy is it to maintain and modify?\n   - Code organization\n   - Documentation\n   - Code clarity\n   - Modularity\n\n2. **Complexity**: How complex is the codebase?\n   - Cyclomatic complexity\n   - Code duplication\n   - Nested structures\n   - Dependencies\n\n3. **Testability**: How easy is it to test?\n   - Test coverage potential\n   - Code isolation\n   - Mockability\n   - Test infrastructure\n\n4. **Security**: How secure is the code?\n   - Security vulnerabilities\n   - Best practices\n   - Input validation\n   - Data protection\n\n5. **Performance**: How performant is the code?\n   - Algorithm efficiency\n   - Resource usage\n   - Optimization opportunities\n   - Scalability\n\n6. **Overall Score**: Weighted average of all metrics\n\n7. **Recommendations**: Specific actionable recommendations\n\n8. **Trends**: What's improving vs degrading\n\nReturn ONLY valid JSON:\n{\n  \"maintainability\": 75,\n  \"complexity\": 60,\n  \"testability\": 80,\n  \"security\": 70,\n  \"performance\": 85,\n  \"overall\": 74,\n  \"recommendations\": [\n    \"Add input validation\",\n    \"Reduce code duplication\"\n  ],\n  \"trends\": {\n    \"improvement\": [\"Better error handling\", \"Improved structure\"],\n    \"degradation\": [\"Increased complexity\", \"Security issues\"]\n  }\n}`;\n\n  try {\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    if (!text || text.trim().length === 0) {\n      throw new Error('Empty response from AI model');\n    }\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      console.error('No JSON found in response. Response text:', text.substring(0, 500));\n      throw new Error('No JSON found in AI response');\n    }\n\n    let data;\n    try {\n      data = JSON.parse(jsonMatch[0]);\n    } catch (parseError) {\n      console.error('JSON parse error. JSON string:', jsonMatch[0].substring(0, 500));\n      throw new Error('Failed to parse JSON from AI response');\n    }\n\n    return {\n      maintainability: data.maintainability || 0,\n      complexity: data.complexity || 0,\n      testability: data.testability || 0,\n      security: data.security || 0,\n      performance: data.performance || 0,\n      overall: data.overall || 0,\n      recommendations: Array.isArray(data.recommendations) ? data.recommendations : [],\n      trends: data.trends || {\n        improvement: [],\n        degradation: []\n      }\n    };\n  } catch (error: any) {\n    console.error('Error calculating code metrics:', error);\n    \n    // Check if it's a quota error\n    if (error.message?.includes('429') || error.message?.includes('quota') || error.message?.includes('RESOURCE_EXHAUSTED')) {\n      const quotaError = {\n        error: {\n          code: 429,\n          message: 'API quota exceeded. Please wait or use a different API key.',\n          status: 'RESOURCE_EXHAUSTED'\n        }\n      };\n      throw new Error(JSON.stringify(quotaError));\n    }\n    \n    throw error;\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/contextAwareFix.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface ContextAwareFix {\n  issue: CodeIssue;\n  questions: string[];\n  businessLogicConsiderations: string[];\n  fixedCode: string;\n  explanation: string;\n  confidence: 'high' | 'medium' | 'low';\n  requiresConfirmation: boolean;\n}\n\n/**\n * Generate context-aware fix that respects business logic\n */\nexport async function generateContextAwareFix(\n  issue: CodeIssue,\n  fileContent: string,\n  codebaseContext: string\n): Promise<ContextAwareFix> {\n  const prompt = `You are an expert code reviewer. Generate a fix for this issue that respects business logic and context.\n\nIssue:\n- Type: ${issue.type}\n- Severity: ${issue.severity}\n- File: ${issue.file}\n- Description: ${issue.description}\n\nFile Code:\n${fileContent}\n\nFull Codebase Context:\n${codebaseContext}\n\nBefore fixing, analyze:\n\n1. **Business Logic Questions:**\n   - Ask critical questions about the intended behavior\n   - Example: \"Is pixel_id allowed to be dynamic?\" or \"Should this parameter be user-controlled?\"\n   - Identify assumptions that need clarification\n\n2. **Business Logic Considerations:**\n   - What business rules might be affected?\n   - Are there dependencies on this code?\n   - What is the intended behavior vs current behavior?\n\n3. **Generate Fix:**\n   - Provide fixed code that respects business logic\n   - Explain why this fix is safe\n   - Note if confirmation is needed\n\nReturn ONLY valid JSON:\n{\n  \"questions\": [\n    \"Is pixel_id allowed to be dynamic?\",\n    \"Should this be user-controlled?\"\n  ],\n  \"businessLogicConsiderations\": [\n    \"This fix might affect tracking accuracy\",\n    \"Need to verify if dynamic IDs are required\"\n  ],\n  \"fixedCode\": \"complete fixed code here\",\n  \"explanation\": \"why this fix is safe and respects business logic\",\n  \"confidence\": \"high\",\n  \"requiresConfirmation\": true\n}`;\n\n  try {\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    return {\n      issue,\n      questions: data.questions || [],\n      businessLogicConsiderations: data.businessLogicConsiderations || [],\n      fixedCode: data.fixedCode || '',\n      explanation: data.explanation || '',\n      confidence: data.confidence || 'medium',\n      requiresConfirmation: data.requiresConfirmation || false\n    };\n  } catch (error) {\n    console.error('Error generating context-aware fix:', error);\n    throw error;\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/fixExplainer.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface FixExplanation {\n  issue: CodeIssue;\n  whyDangerous: string;\n  howToFixManually: string;\n  impact: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  estimatedTime: string;\n  difficulty: 'easy' | 'medium' | 'hard';\n}\n\n/**\n * Explain how to fix an issue\n */\nexport async function explainFix(\n  issue: CodeIssue,\n  fileContent: string,\n  codebaseContext?: string\n): Promise<FixExplanation> {\n  if (!fileContent) {\n    throw new Error('File content is required to explain fix');\n  }\n  const prompt = `You are an expert code reviewer. Explain this security/code issue in detail.\n\nIssue:\n- Type: ${issue.type}\n- Severity: ${issue.severity}\n- File: ${issue.file}\n- Line: ${issue.line || 'N/A'}\n- Description: ${issue.description}\n- Suggestion: ${issue.suggestion || 'None'}\n\nCode Context:\n${fileContent}\n\n${codebaseContext ? `Full Codebase Context:\\n${codebaseContext}` : ''}\n\nProvide a comprehensive explanation with:\n\n1. **Why is this dangerous?**\n   - Explain the security risk or bug impact\n   - What could happen if not fixed\n   - Real-world attack scenarios (if security issue)\n\n2. **How to fix manually:**\n   - Step-by-step instructions\n   - Code examples\n   - Best practices to follow\n\n3. **Impact:**\n   - What will be affected if we fix this\n   - Breaking changes (if any)\n   - Performance implications\n\n4. **Priority Assessment:**\n   - Critical: Fix immediately (security/data loss risk)\n   - High: Fix soon (major functionality issue)\n   - Medium: Fix when possible (minor issues)\n   - Low: Nice to have (code quality)\n\n5. **Estimated Time:**\n   - How long it takes to fix (e.g., \"5 minutes\", \"1 hour\", \"2-3 hours\")\n\n6. **Difficulty:**\n   - Easy: Simple fix, low risk\n   - Medium: Requires some understanding\n   - Hard: Complex fix, needs careful testing\n\nReturn ONLY valid JSON:\n{\n  \"whyDangerous\": \"detailed explanation of why this is dangerous...\",\n  \"howToFixManually\": \"step-by-step instructions...\",\n  \"impact\": \"what will be affected...\",\n  \"priority\": \"critical\",\n  \"estimatedTime\": \"30 minutes\",\n  \"difficulty\": \"medium\"\n}`;\n\n  try {\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    return {\n      issue,\n      whyDangerous: data.whyDangerous || '',\n      howToFixManually: data.howToFixManually || '',\n      impact: data.impact || '',\n      priority: data.priority || 'medium',\n      estimatedTime: data.estimatedTime || 'Unknown',\n      difficulty: data.difficulty || 'medium'\n    };\n  } catch (error) {\n    console.error('Error explaining fix:', error);\n    throw error;\n  }\n}\n\n/**\n * Explain multiple fixes\n */\nexport async function explainFixes(\n  issues: CodeIssue[],\n  files: Array<{ path: string; content: string }>\n): Promise<FixExplanation[]> {\n  const explanations: FixExplanation[] = [];\n\n  if (!files || files.length === 0) {\n    throw new Error('Files array is required and cannot be empty');\n  }\n\n  for (const issue of issues) {\n    const file = files.find(f => f.path === issue.file || f.path.endsWith(issue.file));\n    if (file && file.content) {\n      try {\n        const explanation = await explainFix(issue, file.content);\n        explanations.push(explanation);\n      } catch (error: any) {\n        console.error(`Error explaining fix for ${issue.file}:`, error);\n        // Add a basic explanation even if API fails\n        explanations.push({\n          issue,\n          whyDangerous: `This ${issue.type} issue (${issue.severity} severity) needs attention.`,\n          howToFixManually: issue.suggestion || 'Please review the code and apply appropriate fixes.',\n          impact: 'This issue may affect code quality, security, or functionality.',\n          priority: issue.severity === 'high' ? 'high' : 'medium' as 'critical' | 'high' | 'medium' | 'low',\n          estimatedTime: 'Unknown',\n          difficulty: 'medium'\n        });\n      }\n    } else {\n      console.warn(`File not found for issue: ${issue.file}`);\n      // Add a basic explanation even if file not found\n      explanations.push({\n        issue,\n        whyDangerous: `This ${issue.type} issue (${issue.severity} severity) needs attention.`,\n        howToFixManually: issue.suggestion || 'Please review the code and apply appropriate fixes.',\n        impact: 'This issue may affect code quality, security, or functionality.',\n        priority: issue.severity === 'high' ? 'high' : 'medium' as 'critical' | 'high' | 'medium' | 'low',\n        estimatedTime: 'Unknown',\n        difficulty: 'medium'\n      });\n    }\n  }\n\n  return explanations;\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/marathonAgent.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface MarathonTask {\n  id: string;\n  repoUrl: string;\n  status: 'running' | 'paused' | 'completed' | 'error';\n  startTime: Date;\n  lastCheck: Date;\n  issuesFound: CodeIssue[];\n  testsRun: number;\n  testsPassed: number;\n  testsFailed: number;\n  thoughtSignature?: string;\n}\n\nexport interface MarathonConfig {\n  repoUrl: string;\n  testInterval: number;\n  autoFix: boolean;\n  notifyOnIssue: boolean;\n}\n\nconst THOUGHT_SIGNATURE_PROMPT = `Generate a thought signature for this testing cycle.\n\nPrevious context: {PREVIOUS_CONTEXT}\nCurrent time: {CURRENT_TIME}\nTask ID: {TASK_ID}\n\nCreate a concise signature that captures:\n- What has been tested so far\n- What issues were found\n- What fixes were applied\n- Current state of the codebase\n\nReturn ONLY a JSON object:\n{\n  \"signature\": \"concise signature string\",\n  \"summary\": \"brief summary of current state\"\n}`;\n\nconst ANALYSIS_PROMPT = `Analyze this codebase for issues. Use the previous context to avoid redundant checks.\n\nPrevious Thought Signature: {THOUGHT_SIGNATURE}\nRepository: {REPO_URL}\nLast Check: {LAST_CHECK}\n\nFocus on:\n1. New issues since last check\n2. Previously found issues that may have been fixed\n3. New code changes that need testing\n\nReturn ONLY valid JSON:\n{\n  \"issues\": [\n    {\n      \"type\": \"bug\",\n      \"severity\": \"high\",\n      \"file\": \"app/api/users.ts\",\n      \"line\": 45,\n      \"description\": \"Issue description\",\n      \"suggestion\": \"How to fix\"\n    }\n  ],\n  \"testsRun\": 10,\n  \"testsPassed\": 8,\n  \"testsFailed\": 2\n}`;\n\nexport class MarathonAgent {\n  private task: MarathonTask;\n  private config: MarathonConfig;\n  private intervalId?: NodeJS.Timeout;\n  private thoughtSignature: string = '';\n\n  constructor(config: MarathonConfig) {\n    this.config = config;\n    this.task = {\n      id: `task-${Date.now()}`,\n      repoUrl: config.repoUrl,\n      status: 'running',\n      startTime: new Date(),\n      lastCheck: new Date(),\n      issuesFound: [],\n      testsRun: 0,\n      testsPassed: 0,\n      testsFailed: 0\n    };\n  }\n\n  async start(): Promise<void> {\n    await this.runFullAnalysis();\n    this.intervalId = setInterval(async () => {\n      await this.periodicCheck();\n    }, this.config.testInterval * 60 * 1000);\n  }\n\n  stop(): void {\n    if (this.intervalId) clearInterval(this.intervalId);\n    this.task.status = 'paused';\n    this.saveThoughtSignature();\n  }\n\n  async runFullAnalysis(): Promise<void> {\n    try {\n      this.task.status = 'running';\n      this.task.lastCheck = new Date();\n      this.loadThoughtSignature();\n\n      this.thoughtSignature = await this.generateThoughtSignature();\n      const analysis = await this.analyzeWithContext();\n\n      this.task.issuesFound = analysis.issues;\n      this.task.testsRun += analysis.testsRun || 0;\n      this.task.testsPassed += analysis.testsPassed || 0;\n      this.task.testsFailed += analysis.testsFailed || 0;\n\n      if (this.config.autoFix && analysis.issues.length > 0) {\n        await this.autoFixIssues(analysis.issues);\n      }\n      if (this.config.notifyOnIssue && analysis.issues.length > 0) {\n        await this.notifyIssues(analysis.issues);\n      }\n\n      this.saveThoughtSignature();\n    } catch (error) {\n      console.error('Error in full analysis:', error);\n      this.task.status = 'error';\n    }\n  }\n\n  async periodicCheck(): Promise<void> {\n    await this.runFullAnalysis();\n  }\n\n  private async generateThoughtSignature(): Promise<string> {\n    const prompt = THOUGHT_SIGNATURE_PROMPT\n      .replace('{PREVIOUS_CONTEXT}', this.thoughtSignature || 'None')\n      .replace('{CURRENT_TIME}', new Date().toISOString())\n      .replace('{TASK_ID}', this.task.id);\n\n    try {\n      const result = await generateContentWithFallback(prompt);\n      const text = result.text || '';\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const data = JSON.parse(jsonMatch[0]);\n        return data.signature || '';\n      }\n    } catch (error) {\n      console.error('Error generating thought signature:', error);\n    }\n    return '';\n  }\n\n  private async analyzeWithContext(): Promise<{\n    issues: CodeIssue[];\n    testsRun?: number;\n    testsPassed?: number;\n    testsFailed?: number;\n  }> {\n    const prompt = ANALYSIS_PROMPT\n      .replace('{THOUGHT_SIGNATURE}', this.thoughtSignature)\n      .replace('{REPO_URL}', this.config.repoUrl)\n      .replace('{LAST_CHECK}', this.task.lastCheck.toISOString());\n\n    try {\n      const result = await generateContentWithFallback(prompt);\n      const text = result.text || '';\n      const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) return JSON.parse(jsonMatch[0]);\n    } catch (error) {\n      console.error('Error in analysis with context:', error);\n    }\n    return { issues: [] };\n  }\n\n  private async autoFixIssues(issues: CodeIssue[]): Promise<void> {\n    // Auto-fix high severity issues\n    issues.filter(i => i.severity === 'high');\n  }\n\n  private async notifyIssues(issues: CodeIssue[]): Promise<void> {\n    // Notify about high severity issues\n    issues.filter(i => i.severity === 'high');\n  }\n\n  private saveThoughtSignature(): void {\n    this.task.thoughtSignature = this.thoughtSignature;\n  }\n\n  private loadThoughtSignature(): void {\n    if (this.task.thoughtSignature) {\n      this.thoughtSignature = this.task.thoughtSignature;\n    }\n  }\n\n  getStatus(): MarathonTask {\n    return { ...this.task };\n  }\n}\n\nexport function createMarathonAgent(config: MarathonConfig): MarathonAgent {\n  return new MarathonAgent(config);\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/reasoningChains.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeFile, CodeIssue } from './codeAnalyzer';\n\nexport interface ReasoningStep {\n  step: number;\n  thought: string;\n  analysis: string;\n  conclusion: string;\n  confidence: 'high' | 'medium' | 'low';\n}\n\nexport interface ReasoningChain {\n  issue: CodeIssue;\n  steps: ReasoningStep[];\n  finalDecision: string;\n  reasoningPath: string;\n}\n\n/**\n * Generate reasoning chain for an issue\n * Shows step-by-step how the AI thinks about the problem\n */\nexport async function generateReasoningChain(\n  issue: CodeIssue,\n  fileContent: string,\n  codebaseContext?: string\n): Promise<ReasoningChain> {\n  const prompt = `You are an expert code analyzer. Analyze this issue step-by-step, showing your reasoning process.\n\nIssue:\n- Type: ${issue.type}\n- Severity: ${issue.severity}\n- File: ${issue.file}\n- Description: ${issue.description}\n- Suggestion: ${issue.suggestion || 'None'}\n\nFile Code:\n${fileContent}\n\n${codebaseContext ? `Full Codebase Context:\\n${codebaseContext}` : ''}\n\nAnalyze this issue using a step-by-step reasoning chain. For each step, show:\n\n1. **Your Thought**: What you're thinking about\n2. **Analysis**: What you're analyzing\n3. **Conclusion**: What you conclude from this step\n4. **Confidence**: How confident you are (high/medium/low)\n\nProvide 3-5 reasoning steps that lead to understanding the issue and how to fix it.\n\nReturn ONLY valid JSON:\n{\n  \"steps\": [\n    {\n      \"step\": 1,\n      \"thought\": \"First, I need to understand...\",\n      \"analysis\": \"Looking at the code...\",\n      \"conclusion\": \"I can see that...\",\n      \"confidence\": \"high\"\n    },\n    {\n      \"step\": 2,\n      \"thought\": \"Next, I should check...\",\n      \"analysis\": \"Examining the context...\",\n      \"conclusion\": \"This reveals...\",\n      \"confidence\": \"medium\"\n    }\n  ],\n  \"finalDecision\": \"Based on my analysis, this issue requires...\",\n  \"reasoningPath\": \"Step 1  Step 2  Step 3  Final Decision\"\n}`;\n\n  try {\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error('No JSON found in response');\n    }\n\n    const data = JSON.parse(jsonMatch[0]);\n\n    return {\n      issue,\n      steps: data.steps || [],\n      finalDecision: data.finalDecision || '',\n      reasoningPath: data.reasoningPath || ''\n    };\n  } catch (error) {\n    console.error('Error generating reasoning chain:', error);\n    throw error;\n  }\n}\n\n/**\n * Generate reasoning chains for multiple issues\n */\nexport async function generateReasoningChains(\n  issues: CodeIssue[],\n  files: Array<{ path: string; content: string }>\n): Promise<ReasoningChain[]> {\n  const chains: ReasoningChain[] = [];\n\n  for (const issue of issues) {\n    const file = files.find(f => f.path === issue.file || f.path.endsWith(issue.file));\n    if (file && file.content) {\n      try {\n        const chain = await generateReasoningChain(\n          issue,\n          file.content,\n          files.map(f => f.content).join('\\n\\n')\n        );\n        chains.push(chain);\n      } catch (error) {\n        console.error(`Error generating reasoning chain for ${issue.file}:`, error);\n        // Add a basic chain even if API fails\n        chains.push({\n          issue,\n          steps: [{\n            step: 1,\n            thought: `Analyzing ${issue.type} issue`,\n            analysis: issue.description,\n            conclusion: issue.suggestion || 'Requires manual review',\n            confidence: 'medium'\n          }],\n          finalDecision: issue.suggestion || 'Manual review recommended',\n          reasoningPath: 'Basic analysis  Review needed'\n        });\n      }\n    }\n  }\n\n  return chains;\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/repoReader.ts",
        "content": "import { CodeFile } from './codeAnalyzer';\n\n/**\n * Read files from uploaded files (FormData)\n */\nexport async function readFilesFromUpload(formData: FormData): Promise<CodeFile[]> {\n  const files: CodeFile[] = [];\n  const fileEntries = Array.from(formData.entries());\n\n  for (const [key, value] of fileEntries) {\n    if (value instanceof File) {\n      const content = await value.text();\n      const path = value.webkitRelativePath || value.name;\n      \n      files.push({\n        path,\n        content,\n        language: detectLanguage(path)\n      });\n    }\n  }\n\n  return files;\n}\n\n/**\n * Count all files in GitHub repository (including non-code files)\n */\nexport async function countAllFilesFromGitHub(repoUrl: string): Promise<number> {\n  try {\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) {\n      throw new Error('Invalid GitHub URL');\n    }\n\n    const [, owner, repo] = match;\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    const count = { value: 0 };\n    await countFilesRecursive(baseUrl, owner, repo, count);\n    return count.value;\n  } catch (error) {\n    console.error('Error counting files from GitHub:', error);\n    return 0;\n  }\n}\n\nasync function countFilesRecursive(\n  url: string,\n  owner: string,\n  repo: string,\n  count: { value: number }\n): Promise<void> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) return;\n    \n    const items = await response.json();\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    for (const item of itemsArray) {\n      if (item.type === 'dir') {\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        await countFilesRecursive(subUrl, owner, repo, count);\n      } else if (item.type === 'file') {\n        count.value++;\n      }\n    }\n  } catch (error) {\n    console.error(`Error counting files in ${url}:`, error);\n  }\n}\n\n/**\n * Read files from GitHub repository using Contents API\n */\nexport async function readFilesFromGitHub(repoUrl: string): Promise<CodeFile[]> {\n  try {\n    // Extract owner and repo from URL\n    const match = repoUrl.match(/github\\.com\\/([^\\/]+)\\/([^\\/]+)/);\n    if (!match) {\n      throw new Error('Invalid GitHub URL');\n    }\n\n    const [, owner, repo] = match;\n    \n    // Use GitHub Contents API (better than Git Trees API)\n    const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;\n    \n    // Read files recursively starting from root\n    const files = await readDirectoryRecursive(baseUrl, owner, repo);\n    \n    return files;\n  } catch (error) {\n    console.error('Error reading from GitHub:', error);\n    throw error;\n  }\n}\n\n/**\n * Read directory recursively using GitHub Contents API\n */\nasync function readDirectoryRecursive(\n  url: string,\n  owner: string,\n  repo: string,\n  basePath: string = ''\n): Promise<CodeFile[]> {\n  const files: CodeFile[] = [];\n  \n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      // If rate limited or not found, return empty array\n      if (response.status === 403 || response.status === 404) {\n        console.warn(`GitHub API error: ${response.statusText}. Rate limit may be exceeded.`);\n        return [];\n      }\n      throw new Error(`GitHub API error: ${response.statusText}`);\n    }\n\n    const items = await response.json();\n    \n    // Handle both single file and array of items\n    const itemsArray = Array.isArray(items) ? items : [items];\n    \n    // Filter only code files\n    const codeExtensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.java', '.cpp', '.c', '.cs', '.go', '.rs', '.php', '.rb', '.swift', '.kt', '.vue', '.svelte'];\n    \n    for (const item of itemsArray) {\n      // Skip if it's a directory marker or not a code file\n      if (item.type === 'dir') {\n        // Recursively read subdirectory\n        const subUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${item.path}`;\n        const subFiles = await readDirectoryRecursive(subUrl, owner, repo, item.path);\n        files.push(...subFiles);\n      } else if (item.type === 'file' && codeExtensions.some(ext => item.name.endsWith(ext))) {\n        try {\n          // Use download_url for direct file content (faster)\n          if (item.download_url) {\n            const fileResponse = await fetch(item.download_url);\n            if (fileResponse.ok) {\n              const content = await fileResponse.text();\n              \n              files.push({\n                path: item.path,\n                content,\n                language: detectLanguage(item.name)\n              });\n            }\n          } else if (item.content) {\n            // Fallback: decode base64 content\n            const content = Buffer.from(item.content, 'base64').toString('utf-8');\n            \n            files.push({\n              path: item.path,\n              content,\n              language: detectLanguage(item.name)\n            });\n          }\n        } catch (error) {\n          console.error(`Error reading file ${item.path}:`, error);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(`Error reading directory ${url}:`, error);\n  }\n  \n  return files;\n}\n\n/**\n * Detect programming language from file path\n */\nfunction detectLanguage(path: string): string {\n  const ext = path.split('.').pop()?.toLowerCase();\n  \n  const languageMap: Record<string, string> = {\n    'ts': 'typescript',\n    'tsx': 'typescript',\n    'js': 'javascript',\n    'jsx': 'javascript',\n    'py': 'python',\n    'java': 'java',\n    'cpp': 'cpp',\n    'c': 'c',\n    'cs': 'csharp',\n    'go': 'go',\n    'rs': 'rust',\n    'php': 'php',\n    'rb': 'ruby',\n    'swift': 'swift',\n    'kt': 'kotlin'\n  };\n\n  return languageMap[ext || ''] || 'unknown';\n}\n\n/**\n * Filter code files (exclude node_modules, .git, etc.)\n */\nexport function filterCodeFiles(files: CodeFile[]): CodeFile[] {\n  const excludePatterns = [\n    /node_modules/,\n    /\\.git/,\n    /\\.next/,\n    /dist/,\n    /build/,\n    /\\.env/,\n    /package-lock\\.json/,\n    /yarn\\.lock/,\n    /\\.log$/\n  ];\n\n  return files.filter(file => {\n    return !excludePatterns.some(pattern => pattern.test(file.path));\n  });\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/riskTimeline.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\nimport { CodeIssue } from './codeAnalyzer';\n\nexport interface RiskItem {\n  issue: CodeIssue;\n  riskLevel: 'critical' | 'high' | 'medium' | 'low';\n  urgency: 'fix-now' | 'fix-soon' | 'can-wait' | 'nice-to-have';\n  impact: string;\n  timeline: string;\n}\n\nexport interface RiskTimeline {\n  critical: RiskItem[];\n  high: RiskItem[];\n  medium: RiskItem[];\n  low: RiskItem[];\n  summary: {\n    fixNow: number;\n    fixSoon: number;\n    canWait: number;\n    niceToHave: number;\n  };\n  recommendations: string[];\n}\n\n/**\n * Generate risk timeline - prioritize issues by urgency\n */\nexport async function generateRiskTimeline(\n  issues: CodeIssue[],\n  codebaseContext?: string\n): Promise<RiskTimeline> {\n  const prompt = `Analyze these code issues and create a risk timeline prioritizing what needs to be fixed.\n\nIssues:\n${issues.map((issue, i) => \n  `${i + 1}. ${issue.type} (${issue.severity}): ${issue.description} - File: ${issue.file}`\n).join('\\n')}\n\n${codebaseContext ? `Codebase Context:\\n${codebaseContext}` : ''}\n\nFor each issue, determine:\n\n1. **Risk Level:**\n   - Critical: Security/data loss risk, breaks functionality\n   - High: Major security/functionality issue\n   - Medium: Moderate issue\n   - Low: Minor issue\n\n2. **Urgency:**\n   - fix-now: Must fix immediately (security/data risk)\n   - fix-soon: Fix within days (major functionality)\n   - can-wait: Fix when possible (moderate issues)\n   - nice-to-have: Optional improvements\n\n3. **Impact:**\n   - What happens if not fixed\n   - Who/what is affected\n\n4. **Timeline:**\n   - When should this be fixed (e.g., \"Today\", \"This week\", \"This month\", \"Next sprint\")\n\n5. **Overall Recommendations:**\n   - What should be fixed first\n   - What can wait\n   - Suggested fix order\n\nReturn ONLY valid JSON:\n{\n  \"critical\": [\n    {\n      \"issue\": { \"type\": \"security\", \"severity\": \"high\", ... },\n      \"riskLevel\": \"critical\",\n      \"urgency\": \"fix-now\",\n      \"impact\": \"Allows attacker to hijack tracking\",\n      \"timeline\": \"Today\"\n    }\n  ],\n  \"high\": [...],\n  \"medium\": [...],\n  \"low\": [...],\n  \"summary\": {\n    \"fixNow\": 2,\n    \"fixSoon\": 3,\n    \"canWait\": 2,\n    \"niceToHave\": 1\n  },\n  \"recommendations\": [\n    \"Fix security issues first\",\n    \"Address high-severity bugs this week\"\n  ]\n}`;\n\n  try {\n    const result = await generateContentWithFallback(prompt);\n    const text = result.text || '';\n\n    if (!text || text.trim().length === 0) {\n      throw new Error('Empty response from AI model');\n    }\n\n    const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      console.error('No JSON found in response. Response text:', text.substring(0, 500));\n      throw new Error('No JSON found in AI response');\n    }\n\n    let data;\n    try {\n      data = JSON.parse(jsonMatch[0]);\n    } catch (parseError) {\n      console.error('JSON parse error. JSON string:', jsonMatch[0].substring(0, 500));\n      throw new Error('Failed to parse JSON from AI response');\n    }\n\n    // Map issues back to original\n    const mapIssues = (items: any[]) => {\n      if (!Array.isArray(items)) return [];\n      return items.map((item: any) => {\n        const originalIssue = issues.find(i => \n          i.file === item.issue?.file && \n          i.description === item.issue?.description\n        );\n        return {\n          ...item,\n          issue: originalIssue || item.issue\n        };\n      });\n    };\n\n    return {\n      critical: mapIssues(data.critical || []),\n      high: mapIssues(data.high || []),\n      medium: mapIssues(data.medium || []),\n      low: mapIssues(data.low || []),\n      summary: data.summary || {\n        fixNow: 0,\n        fixSoon: 0,\n        canWait: 0,\n        niceToHave: 0\n      },\n      recommendations: Array.isArray(data.recommendations) ? data.recommendations : []\n    };\n  } catch (error: any) {\n    console.error('Error generating risk timeline:', error);\n    \n    // Check if it's a quota error\n    if (error.message?.includes('429') || error.message?.includes('quota') || error.message?.includes('RESOURCE_EXHAUSTED')) {\n      const quotaError = {\n        error: {\n          code: 429,\n          message: 'API quota exceeded. Please wait or use a different API key.',\n          status: 'RESOURCE_EXHAUSTED'\n        }\n      };\n      throw new Error(JSON.stringify(quotaError));\n    }\n    \n    throw error;\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/sessionStorage.ts",
        "content": "export interface Session {\n  id: string;\n  name: string;\n  timestamp: number;\n  repoUrl?: string;\n  results: any;\n  config: {\n    testTypes: string[];\n    duration: string;\n    autoFix: boolean;\n  };\n}\n\n// Save session to server (JSON file)\nexport async function saveSession(session: Omit<Session, 'id' | 'timestamp'>): Promise<Session> {\n  try {\n    const response = await fetch('/api/sessions', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(session)\n    });\n    \n    const data = await response.json();\n    if (data.success) {\n      return data.session;\n    }\n    throw new Error(data.message || 'Failed to save session');\n  } catch (error) {\n    console.error('Failed to save session:', error);\n    throw error;\n  }\n}\n\n// Get all sessions from server\nexport async function getSessions(): Promise<Session[]> {\n  try {\n    const response = await fetch('/api/sessions');\n    const data = await response.json();\n    if (data.success) {\n      return data.sessions || [];\n    }\n    return [];\n  } catch (error) {\n    console.error('Failed to load sessions:', error);\n    return [];\n  }\n}\n\n// Get a specific session by ID\nexport async function getSession(id: string): Promise<Session | null> {\n  try {\n    const response = await fetch(`/api/sessions/${id}`);\n    const data = await response.json();\n    if (data.success) {\n      return data.session;\n    }\n    return null;\n  } catch (error) {\n    console.error('Failed to get session:', error);\n    return null;\n  }\n}\n\n// Delete a session by ID\nexport async function deleteSession(id: string): Promise<void> {\n  try {\n    const response = await fetch(`/api/sessions/${id}`, {\n      method: 'DELETE'\n    });\n    const data = await response.json();\n    if (!data.success) {\n      throw new Error(data.message || 'Failed to delete session');\n    }\n  } catch (error) {\n    console.error('Failed to delete session:', error);\n    throw error;\n  }\n}\n\n// Clear all sessions (not implemented in API, but kept for compatibility)\nexport async function clearAllSessions(): Promise<void> {\n  console.warn('clearAllSessions is not implemented. Delete sessions individually.');\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/testGenerator.ts",
        "content": "import { generateContentWithFallback } from '../utils/aiHelper';\n\nexport interface TestCase {\n  name: string;\n  type: 'unit' | 'integration' | 'security' | 'performance';\n  code: string;\n  description: string;\n}\n\nexport interface GeneratedTests {\n  unitTests: TestCase[];\n  integrationTests: TestCase[];\n  securityTests: TestCase[];\n  performanceTests: TestCase[];\n  total: number;\n}\n\nconst UNIT_TEST_PROMPT = `Generate comprehensive unit tests for this codebase.\n\nCodebase:\n{CODEBASE}\n\nGenerate unit tests for each function/component. Include:\n- Happy path tests\n- Edge cases\n- Error handling\n- Boundary conditions\n- Null/undefined checks\n\nFor each test, provide:\n- Test name (descriptive)\n- Test code (complete, runnable)\n- Description\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"name\": \"testCalculateTotalWithValidInput\",\n    \"type\": \"unit\",\n    \"code\": \"describe('calculateTotal', () => { ... })\",\n    \"description\": \"Tests calculateTotal function with valid input\"\n  }\n]`;\n\nconst INTEGRATION_TEST_PROMPT = `Generate integration tests for this codebase.\n\nCodebase:\n{CODEBASE}\n\nGenerate integration tests that test:\n- Component interactions\n- API endpoints\n- Database operations\n- Data flow between components\n- External service integrations\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"name\": \"testUserLoginFlow\",\n    \"type\": \"integration\",\n    \"code\": \"describe('User Login Flow', () => { ... })\",\n    \"description\": \"Tests complete user login flow\"\n  }\n]`;\n\nconst SECURITY_TEST_PROMPT = `Generate security tests for this codebase.\n\nCodebase:\n{CODEBASE}\n\nGenerate security tests for:\n- SQL Injection vulnerabilities\n- XSS (Cross-Site Scripting) attacks\n- Authentication bypass\n- Authorization issues\n- Input validation\n- CSRF protection\n- Secure data handling\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"name\": \"testSQLInjectionPrevention\",\n    \"type\": \"security\",\n    \"code\": \"describe('SQL Injection Prevention', () => { ... })\",\n    \"description\": \"Tests that SQL injection attacks are prevented\"\n  }\n]`;\n\nconst PERFORMANCE_TEST_PROMPT = `Generate performance tests for this codebase.\n\nCodebase:\n{CODEBASE}\n\nGenerate performance tests for:\n- Response time\n- Memory usage\n- Database query performance\n- API endpoint performance\n- Component render time\n- Load testing scenarios\n\nReturn ONLY valid JSON array:\n[\n  {\n    \"name\": \"testApiResponseTime\",\n    \"type\": \"performance\",\n    \"code\": \"describe('API Performance', () => { ... })\",\n    \"description\": \"Tests API response time is under threshold\"\n  }\n]`;\n\nasync function generateTestType(codebase: string, prompt: string): Promise<TestCase[]> {\n  try {\n    const result = await generateContentWithFallback(prompt.replace('{CODEBASE}', codebase));\n    const text = result.text || '';\n    const jsonMatch = text.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) return [];\n    return JSON.parse(jsonMatch[0]);\n  } catch (error) {\n    console.error('Error generating tests:', error);\n    return [];\n  }\n}\n\n/**\n * Generate comprehensive tests for codebase\n */\nexport async function generateTests(\n  files: Array<{ path: string; content: string }>,\n  testTypes: ('unit' | 'integration' | 'security' | 'performance')[] = ['unit', 'integration', 'security']\n): Promise<GeneratedTests> {\n  try {\n    const codebaseContent = files\n      .map(file => `File: ${file.path}\\n${file.content}`)\n      .join('\\n\\n---\\n\\n');\n\n    const tests: GeneratedTests = {\n      unitTests: [],\n      integrationTests: [],\n      securityTests: [],\n      performanceTests: [],\n      total: 0\n    };\n\n    if (testTypes.includes('unit')) {\n      tests.unitTests = await generateTestType(codebaseContent, UNIT_TEST_PROMPT);\n    }\n    if (testTypes.includes('integration')) {\n      tests.integrationTests = await generateTestType(codebaseContent, INTEGRATION_TEST_PROMPT);\n    }\n    if (testTypes.includes('security')) {\n      tests.securityTests = await generateTestType(codebaseContent, SECURITY_TEST_PROMPT);\n    }\n    if (testTypes.includes('performance')) {\n      tests.performanceTests = await generateTestType(codebaseContent, PERFORMANCE_TEST_PROMPT);\n    }\n\n    tests.total = tests.unitTests.length + \n                  tests.integrationTests.length + \n                  tests.securityTests.length + \n                  tests.performanceTests.length;\n\n    return tests;\n  } catch (error) {\n    console.error('Error generating tests:', error);\n    throw error;\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/services/testRunner.ts",
        "content": "import { TestCase } from './testGenerator';\n\nexport interface TestResult {\n  name: string;\n  status: 'passed' | 'failed' | 'skipped';\n  duration: number;\n  error?: string;\n}\n\nexport interface TestSuiteResult {\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  duration: number;\n  results: TestResult[];\n  coverage?: {\n    statements: number;\n    branches: number;\n    functions: number;\n    lines: number;\n  };\n}\n\n/**\n * Run tests (simulated - in production would actually execute tests)\n */\nexport async function runTests(tests: TestCase[]): Promise<TestSuiteResult> {\n  const results: TestResult[] = [];\n  let passed = 0;\n  let failed = 0;\n  let skipped = 0;\n  const startTime = Date.now();\n\n  // Simulate test execution\n  for (const test of tests) {\n    const testStart = Date.now();\n    \n    try {\n      // In production, this would actually execute the test\n      // For now, simulate based on test type\n      const status = simulateTestExecution(test);\n      \n      if (status === 'passed') {\n        passed++;\n      } else if (status === 'failed') {\n        failed++;\n      } else {\n        skipped++;\n      }\n\n      results.push({\n        name: test.name,\n        status,\n        duration: Date.now() - testStart,\n        error: status === 'failed' ? 'Test assertion failed' : undefined\n      });\n    } catch (error: any) {\n      failed++;\n      results.push({\n        name: test.name,\n        status: 'failed',\n        duration: Date.now() - testStart,\n        error: error.message\n      });\n    }\n  }\n\n  const duration = Date.now() - startTime;\n\n  // Calculate coverage (simulated)\n  const coverage = calculateCoverage(results, tests.length);\n\n  return {\n    total: tests.length,\n    passed,\n    failed,\n    skipped,\n    duration,\n    results,\n    coverage\n  };\n}\n\n/**\n * Simulate test execution\n */\nfunction simulateTestExecution(test: TestCase): 'passed' | 'failed' | 'skipped' {\n  // In production, this would actually run the test\n  // For now, simulate 80% pass rate\n  const random = Math.random();\n  \n  if (random < 0.8) {\n    return 'passed';\n  } else if (random < 0.95) {\n    return 'failed';\n  } else {\n    return 'skipped';\n  }\n}\n\n/**\n * Calculate test coverage (simulated)\n */\nfunction calculateCoverage(results: TestResult[], totalTests: number): {\n  statements: number;\n  branches: number;\n  functions: number;\n  lines: number;\n} {\n  const passRate = results.filter(r => r.status === 'passed').length / totalTests;\n  \n  // Simulate coverage based on pass rate\n  const baseCoverage = Math.min(95, passRate * 100 + 10);\n  \n  return {\n    statements: Math.round(baseCoverage),\n    branches: Math.round(baseCoverage * 0.9),\n    functions: Math.round(baseCoverage * 0.95),\n    lines: Math.round(baseCoverage)\n  };\n}\n\n/**\n * Write test files to disk (for actual execution)\n */\nexport async function writeTestFiles(\n  tests: TestCase[],\n  outputDir: string = './tests'\n): Promise<string[]> {\n  const filePaths: string[] = [];\n  \n  // Group tests by type\n  const testsByType = {\n    unit: tests.filter(t => t.type === 'unit'),\n    integration: tests.filter(t => t.type === 'integration'),\n    security: tests.filter(t => t.type === 'security'),\n    performance: tests.filter(t => t.type === 'performance')\n  };\n\n  // In production, would use fs to write files\n  // For now, return paths that would be created\n  for (const [type, typeTests] of Object.entries(testsByType)) {\n    if (typeTests.length > 0) {\n      const fileName = `${type}.test.ts`;\n      const filePath = `${outputDir}/${fileName}`;\n      filePaths.push(filePath);\n      \n      // In production:\n      // await fs.writeFile(filePath, generateTestFile(typeTests));\n    }\n  }\n\n  return filePaths;\n}\n\n/**\n * Generate test file content\n */\nfunction generateTestFile(tests: TestCase[]): string {\n  return tests.map(test => test.code).join('\\n\\n');\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/types/index.ts",
        "content": "// ===== Core Types =====\nexport type Severity = 'high' | 'medium' | 'low';\nexport type IssueType = 'bug' | 'security' | 'performance' | 'quality' | 'error_handling';\nexport type TestType = 'unit' | 'integration' | 'security' | 'performance';\nexport type Duration = 'one-time' | 'continuous';\nexport type Priority = 'critical' | 'high' | 'medium' | 'low';\nexport type Confidence = 'high' | 'medium' | 'low';\n\n// ===== Code Analysis Types =====\nexport interface CodeFile {\n  path: string;\n  content: string;\n  language?: string;\n}\n\nexport interface CodeIssue {\n  type: IssueType;\n  severity: Severity;\n  file: string;\n  line?: number;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface CodeStructure {\n  mainFiles: string[];\n  dependencies: string[];\n  architecture: string;\n}\n\nexport interface AnalysisScope {\n  analyzedFileTypes: string[];\n  ignoredFileTypes: string[];\n  focus: string;\n}\n\nexport interface CodeAnalysis {\n  totalFiles: number;\n  totalLines: number;\n  issues: CodeIssue[];\n  structure: CodeStructure;\n  summary: string;\n  totalRepoFiles?: number;\n  ignoredFiles?: number;\n  analysisScope?: AnalysisScope;\n}\n\n// ===== Test Types =====\nexport interface TestResult {\n  name: string;\n  passed: boolean;\n  error?: string;\n  duration?: number;\n}\n\nexport interface TestCoverage {\n  statements: number;\n  branches: number;\n  functions: number;\n  lines: number;\n}\n\nexport interface TestResults {\n  passed: number;\n  failed: number;\n  total: number;\n  coverage?: TestCoverage;\n  results?: TestResult[];\n}\n\nexport interface Test {\n  name: string;\n  type: TestType;\n  code: string;\n  description?: string;\n}\n\nexport interface TestSuite {\n  total: number;\n  unitTests: Test[];\n  integrationTests: Test[];\n  securityTests: Test[];\n  performanceTests?: Test[];\n}\n\n// ===== Fix Types =====\nexport interface Fix {\n  issue: CodeIssue;\n  fixedCode: string;\n  explanation: string;\n  confidence?: number;\n}\n\nexport interface ExplainFixData {\n  whyDangerous: string;\n  howToFixManually: string;\n  impact: string;\n  priority?: Priority;\n  estimatedTime?: string;\n  difficulty?: 'easy' | 'medium' | 'hard';\n}\n\nexport interface SmartFixData {\n  fixedCode: string;\n  explanation: string;\n  businessLogicConsiderations?: string;\n}\n\nexport interface ReasoningStep {\n  step: number;\n  thought: string;\n  analysis: string;\n  conclusion: string;\n  confidence: Confidence;\n}\n\nexport interface ReasoningChainData {\n  steps: ReasoningStep[];\n  reasoningPath?: string;\n  finalDecision?: string;\n}\n\n// ===== Business Impact Types =====\nexport interface EstimatedCost {\n  revenue?: string;\n  users?: string;\n  time?: string;\n  reputation?: string;\n}\n\nexport interface BusinessMetrics {\n  conversion?: string;\n  seo?: string;\n  security?: string;\n  performance?: string;\n}\n\nexport interface BusinessImpactData {\n  impactScore: number;\n  priority: Priority;\n  explanation: string;\n  estimatedCost?: EstimatedCost;\n  businessMetrics?: BusinessMetrics;\n  realWorldExample?: string;\n}\n\n// ===== Risk Timeline Types =====\nexport interface TimelineSummary {\n  fixNow: number;\n  fixSoon: number;\n  canWait: number;\n}\n\nexport interface TimelineItem {\n  issue: CodeIssue;\n  priority: string;\n  estimatedTime: string;\n  impact: string;\n}\n\nexport interface RiskTimeline {\n  summary?: TimelineSummary;\n  critical?: TimelineItem[];\n  high?: TimelineItem[];\n  medium?: TimelineItem[];\n  low?: TimelineItem[];\n  recommendations?: string[];\n}\n\n// ===== Code Metrics Types =====\nexport interface ComplexityMetrics {\n  average: number;\n  max: number;\n  distribution: Record<string, number>;\n}\n\nexport interface MaintainabilityMetrics {\n  score: number;\n  factors: string[];\n}\n\nexport interface TestabilityMetrics {\n  score: number;\n  recommendations: string[];\n}\n\nexport interface TechnicalDebtItem {\n  type: string;\n  hours: number;\n}\n\nexport interface TechnicalDebt {\n  hours: number;\n  cost: number;\n  breakdown: TechnicalDebtItem[];\n}\n\nexport interface CodeMetrics {\n  complexity: ComplexityMetrics;\n  maintainability: MaintainabilityMetrics;\n  testability: TestabilityMetrics;\n  technicalDebt: TechnicalDebt;\n}\n\n// ===== Marathon Agent Types =====\nexport type MarathonStatus = 'running' | 'stopped' | 'completed';\n\nexport interface MarathonTask {\n  id: string;\n  status: MarathonStatus;\n  startTime: string;\n  issuesFound?: CodeIssue[];\n  testsRun?: number;\n  lastUpdate?: string;\n}\n\n// ===== Session Types =====\nexport interface IssueData {\n  explainFix?: ExplainFixData;\n  smartFix?: SmartFixData;\n  reasoningChain?: ReasoningChainData;\n  businessImpact?: BusinessImpactData;\n}\n\nexport interface SessionConfig {\n  testTypes: TestType[];\n  duration: Duration;\n  autoFix: boolean;\n}\n\nexport interface SessionResults {\n  analysis: CodeAnalysis;\n  tests: TestSuite;\n  testResults?: TestResults;\n  fixes: Fix[];\n  marathonTask?: MarathonTask;\n  timeline?: RiskTimeline;\n  metrics?: CodeMetrics;\n  files: CodeFile[];\n  issueData?: Record<string, IssueData>;\n  businessImpactData?: Record<string, BusinessImpactData>;\n}\n\nexport interface Session {\n  id: string;\n  name: string;\n  timestamp: number;\n  repoUrl?: string;\n  results: SessionResults;\n  config: SessionConfig;\n}\n\n// ===== API Response Types =====\nexport interface ApiResponse<T = unknown> {\n  success: boolean;\n  message?: string;\n  data?: T;\n}\n\nexport interface ErrorResponse {\n  success: false;\n  message: string;\n  code?: string;\n  status?: number;\n}\n\n// ===== Component Props Types =====\nexport interface IssueItemProps {\n  issue: CodeIssue;\n  cachedData?: IssueData;\n  sessionId?: string;\n  onExplainFix: () => Promise<ExplainFixData | null>;\n  onSmartFix: () => Promise<SmartFixData | null>;\n  onReasoningChain: () => Promise<ReasoningChainData | null>;\n}\n\nexport interface IssuesListProps {\n  results: SessionResults;\n  sessionId?: string;\n  onError?: (message: string, type?: 'error' | 'warning' | 'info') => void;\n}\n\nexport interface ResultsViewProps {\n  results: SessionResults;\n  marathonTaskId?: string | null;\n  sessionId?: string | null;\n  onStopMarathon?: () => void;\n  onError?: (message: string, type?: 'error' | 'warning' | 'info') => void;\n  onRegenerateTimeline?: () => Promise<void>;\n  onRegenerateMetrics?: () => Promise<void>;\n}\n\nexport interface BusinessImpactViewProps {\n  results: SessionResults;\n  sessionId?: string;\n  onError?: (message: string, type?: 'error' | 'warning' | 'info') => void;\n}\n\nexport interface RiskTimelineViewProps {\n  results: SessionResults;\n  onRegenerate?: () => Promise<void>;\n}\n\nexport interface CodeMetricsViewProps {\n  results: SessionResults;\n  onRegenerate?: () => Promise<void>;\n}\n\n// ===== Error Types =====\nexport type ErrorType = 'error' | 'warning' | 'info';\n\nexport interface ErrorState {\n  message: string;\n  type?: ErrorType;\n}\n\n// ===== Progress Types =====\nexport interface ProgressState {\n  step: string;\n  percentage: number;\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/utils/aiHelper.ts",
        "content": "import { GoogleGenAI } from '@google/genai';\n\nconst ai = new GoogleGenAI({});\n\n/**\n * Generate content with fallback to multiple models\n */\nexport async function generateContentWithFallback(prompt: string) {\n  const modelsToTry = [\n    'gemini-3-flash-preview',\n    'gemini-2.5-flash',\n    'gemini-1.5-flash',\n    'gemini-pro'\n  ];\n  \n  for (const modelName of modelsToTry) {\n    try {\n      const response = await ai.models.generateContent({\n        model: modelName,\n        contents: prompt,\n      });\n      return response;\n    } catch (error: any) {\n      if (error.message?.includes('404') || error.message?.includes('not found')) {\n        continue;\n      }\n      throw error;\n    }\n  }\n  \n  throw new Error('No available models found. Please check your API key and region.');\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/utils/apiHelper.ts",
        "content": "import { NextRequest, NextResponse } from 'next/server';\n\nexport function createApiResponse(success: boolean, data: any, message?: string, status: number = 200) {\n  return NextResponse.json(\n    { success, ...data, ...(message && { message }) },\n    { status: success ? 200 : status }\n  );\n}\n\nexport function createErrorResponse(message: string, status: number = 500): NextResponse {\n  return NextResponse.json(\n    { success: false, message },\n    { status }\n  );\n}\n\nexport async function parseJsonBody(request: NextRequest) {\n  try {\n    return await request.json();\n  } catch {\n    return null;\n  }\n}\n\nexport function validateArray(value: any, name: string): NextResponse | null {\n  if (!value || !Array.isArray(value)) {\n    return createErrorResponse(`${name} array is required`, 400);\n  }\n  return null;\n}\n",
        "language": "typescript"
      },
      {
        "path": "lib/utils/fetchHelper.ts",
        "content": "export async function apiFetch(endpoint: string, options: RequestInit = {}) {\n  try {\n    const response = await fetch(endpoint, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n    });\n    \n    if (!response.ok) {\n      let errorData;\n      try {\n        errorData = await response.json();\n      } catch {\n        errorData = { message: `HTTP ${response.status}: ${response.statusText}` };\n      }\n      return { success: false, message: errorData.message || `HTTP ${response.status}` };\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error: any) {\n    return { success: false, message: error.message || 'Network error occurred' };\n  }\n}\n",
        "language": "typescript"
      },
      {
        "path": "next.config.ts",
        "content": "import type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  /* config options here */\n};\n\nexport default nextConfig;\n",
        "language": "typescript"
      }
    ],
    "issueData": {
      "app/api/sessions/[id]/route.ts-security-high-Path Traversal vulnerability. The 'id' parameter f": {
        "explainFix": {
          "issue": {
            "type": "security",
            "severity": "high",
            "file": "app/api/sessions/[id]/route.ts",
            "line": 15,
            "description": "Path Traversal vulnerability. The 'id' parameter from the URL is used directly in 'path.join' without validation, allowing an attacker to read or delete arbitrary JSON files on the server using '../' sequences.",
            "suggestion": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'."
          },
          "whyDangerous": "This security issue (high severity) needs attention.",
          "howToFixManually": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'.",
          "impact": "This issue may affect code quality, security, or functionality.",
          "priority": "high",
          "estimatedTime": "Unknown",
          "difficulty": "medium"
        },
        "smartFix": {
          "success": true,
          "fix": {
            "issue": {
              "type": "security",
              "severity": "high",
              "file": "app/api/sessions/[id]/route.ts",
              "line": 15,
              "description": "Path Traversal vulnerability. The 'id' parameter from the URL is used directly in 'path.join' without validation, allowing an attacker to read or delete arbitrary JSON files on the server using '../' sequences.",
              "suggestion": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'."
            },
            "questions": [
              "Are session IDs always generated using the `session_{timestamp}_{random}` pattern found in the `/api/sessions` POST route?",
              "Is there a requirement for session IDs to contain characters other than alphanumeric, underscores, or hyphens (e.g., for legacy support)?"
            ],
            "businessLogicConsiderations": [
              "The application stores session data as JSON files in a dedicated local directory (`data/sessions`). Directory traversal poses a high risk as it could allow attackers to read or delete sensitive data outside this scope.",
              "Since session IDs are internally generated, we can implement strict input validation without breaking core functionality. The observed generation logic uses `Date.now()` and a base36 random string, which fits within a simple alphanumeric regex.",
              "Using `path.resolve` for the base directory and verifying the prefix of the resulting file path provides an essential layer of defense-in-depth against traversal attacks."
            ],
            "fixedCode": "import { NextRequest } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { createApiResponse, createErrorResponse } from '@/lib/utils/apiHelper';\n\nconst SESSIONS_DIR = path.resolve(process.cwd(), 'data', 'sessions');\n\n/**\n * Validates the session ID and returns a safe absolute path.\n * Prevents Path Traversal by restricting characters and verifying directory bounds.\n */\nfunction getSafeFilePath(id: string): string | null {\n  // Strict regex validation: only allow alphanumeric, underscores, and hyphens.\n  // This explicitly prevents '..', '/', and '\\' traversal characters from being processed.\n  if (!id || !/^[a-zA-Z0-9_-]+$/.test(id)) {\n    return null;\n  }\n\n  const filePath = path.join(SESSIONS_DIR, `${id}.json`);\n\n  // Defense in depth: Ensure the resolved path is still contained within SESSIONS_DIR\n  if (!filePath.startsWith(SESSIONS_DIR)) {\n    return null;\n  }\n\n  return filePath;\n}\n\n// GET: Get a specific session by ID\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n    const filePath = getSafeFilePath(sessionId);\n    \n    if (!filePath) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n    \n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n      return createApiResponse(true, { session });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error getting session:', error);\n    return createErrorResponse(error.message || 'Failed to get session', 500);\n  }\n}\n\n// DELETE: Delete a session by ID\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: sessionId } = await params;\n    const filePath = getSafeFilePath(sessionId);\n\n    if (!filePath) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n    \n    try {\n      await fs.unlink(filePath);\n      return createApiResponse(true, { message: 'Session deleted successfully' });\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw error;\n    }\n  } catch (error: any) {\n    console.error('Error deleting session:', error);\n    return createErrorResponse(error.message || 'Failed to delete session', 500);\n  }\n}\n\n// PATCH: Update session data (for issueData)\nexport async function PATCH(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const { id: sessionId } = await params;\n    const filePath = getSafeFilePath(sessionId);\n\n    if (!filePath) {\n      return createErrorResponse('Invalid session ID format', 400);\n    }\n\n    const body = await request.json();\n\n    try {\n      // Read existing session\n      const content = await fs.readFile(filePath, 'utf-8');\n      const session = JSON.parse(content);\n\n      // Update session with new data\n      if (body.issueData !== undefined) {\n        if (!session.results.issueData) {\n          session.results.issueData = {};\n        }\n        session.results.issueData = { ...session.results.issueData, ...body.issueData };\n      }\n      \n      // Update timeline if provided\n      if (body.results?.timeline !== undefined) {\n        session.results.timeline = body.results.timeline;\n      }\n      \n      // Update metrics if provided\n      if (body.results?.metrics !== undefined) {\n        session.results.metrics = body.results.metrics;\n      }\n      \n      // Update businessImpactData if provided\n      if (body.businessImpactData !== undefined) {\n        if (!session.results.businessImpactData) {\n          session.results.businessImpactData = {};\n        }\n        session.results.businessImpactData = { ...session.results.businessImpactData, ...body.businessImpactData };\n      }\n      \n      // Full results update (for complete replacement)\n      if (body.results && Object.keys(body.results).length > 0) {\n        session.results = { ...session.results, ...body.results };\n      }\n\n      // Save updated session\n      await fs.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');\n      \n      return createApiResponse(true, { session });\n    } catch (fileError: any) {\n      if (fileError.code === 'ENOENT') {\n        return createErrorResponse('Session not found', 404);\n      }\n      throw fileError;\n    }\n  } catch (error: any) {\n    console.error('Error updating session:', error);\n    return createErrorResponse(error.message || 'Failed to update session', 500);\n  }\n}",
            "explanation": "To resolve the Path Traversal vulnerability, I implemented a strict validation helper `getSafeFilePath`. It uses a regular expression to allow only alphanumeric characters, underscores, and hyphens in the `id` parameter. This prevents malicious payloads containing `../` or absolute paths from being processed. Furthermore, I utilized `path.resolve` to define an absolute base directory and added a runtime check to ensure that any constructed file path remains within the intended `SESSIONS_DIR`. This pattern secures the GET, DELETE, and PATCH endpoints against unauthorized file system access.",
            "confidence": "high",
            "requiresConfirmation": false
          }
        },
        "reasoningChain": {
          "issue": {
            "type": "security",
            "severity": "high",
            "file": "app/api/sessions/[id]/route.ts",
            "line": 15,
            "description": "Path Traversal vulnerability. The 'id' parameter from the URL is used directly in 'path.join' without validation, allowing an attacker to read or delete arbitrary JSON files on the server using '../' sequences.",
            "suggestion": "Validate that the 'id' contains only alphanumeric characters and dashes, and ensure the resulting path stays within the 'SESSIONS_DIR' using 'path.resolve'."
          },
          "steps": [
            {
              "step": 1,
              "thought": "Examine how the 'id' parameter is processed and used for file system operations in the provided route handlers.",
              "analysis": "In the GET, DELETE, and PATCH handlers, the 'id' parameter is extracted from the URL and used to construct a fileName (e.g., `${sessionId}.json`). This name is then passed directly into 'path.join(SESSIONS_DIR, fileName)' to create a 'filePath'.",
              "conclusion": "The 'id' parameter is used as a direct component of a file path without any sanitization or validation against directory traversal sequences like '../'.",
              "confidence": "high"
            },
            {
              "step": 2,
              "thought": "Evaluate the potential impact of an attacker providing a malicious 'id' value.",
              "analysis": "If an attacker provides an 'id' such as '../../etc/passwd', 'path.join' will resolve this relative to 'SESSIONS_DIR'. While the code appends '.json', an attacker can target other JSON files outside the intended directory or use null bytes/suffix manipulation in some environments to bypass the extension (though less common in modern Node.js). More critically, they can navigate anywhere within the 'data' or 'app' structure where JSON files might exist.",
              "conclusion": "This confirms a Path Traversal vulnerability (CWE-22), as the application does not restrict file access to the intended 'data/sessions' directory.",
              "confidence": "high"
            },
            {
              "step": 3,
              "thought": "Determine the necessary security controls to remediate the vulnerability.",
              "analysis": "The fix requires two layers of defense: strict input validation and path canonicalization. Input validation ensures only expected characters (alphanumeric and dashes) are accepted. Path canonicalization using 'path.resolve' combined with a check to ensure the resulting path starts with the absolute path of 'SESSIONS_DIR' prevents escaping the sandbox.",
              "conclusion": "Implementing both a regex check on the 'id' and a prefix check on the resolved path will effectively mitigate the risk.",
              "confidence": "high"
            }
          ],
          "finalDecision": "The vulnerability is confirmed. The 'id' parameter must be validated using a regular expression (e.g., /^[a-zA-Z0-9-]+$/) and the final path must be verified using 'path.resolve' to ensure it remains within 'SESSIONS_DIR'.",
          "reasoningPath": "Identify sink  Analyze unsanitized input flow  Confirm traversal risk  Define multi-layered remediation strategy"
        }
      },
      "lib/services/repoReader.ts-performance-medium-Sequential recursive API calls. 'readDirectoryRecu": {
        "reasoningChain": {
          "issue": {
            "type": "performance",
            "severity": "medium",
            "file": "lib/services/repoReader.ts",
            "line": 105,
            "description": "Sequential recursive API calls. 'readDirectoryRecursive' awaits each subdirectory and file download sequentially. For large repositories, this leads to extremely long execution times and potential API timeouts.",
            "suggestion": "Implement concurrency limits using 'Promise.all' with a semaphore or a library like 'p-limit' to fetch multiple files/directories in parallel."
          },
          "steps": [
            {
              "step": 1,
              "thought": "Evaluate the current recursion and execution model of the 'readDirectoryRecursive' function.",
              "analysis": "The function uses a 'for...of' loop containing an 'await' for every subdirectory ('readDirectoryRecursive') and every file download ('fetch'). In JavaScript, this pattern forces sequential execution where the next item in the loop cannot begin until the previous network request is fully completed.",
              "conclusion": "The current architecture is strictly serial, meaning the total execution time is the sum of every individual network request latency, which is highly inefficient for large file trees.",
              "confidence": "high"
            },
            {
              "step": 2,
              "thought": "Assess the impact of sequential API calls on large GitHub repositories.",
              "analysis": "GitHub API requests typically take 100ms-500ms. A repository with 100 code files and 10 directories would take at minimum 11-55 seconds just in network latency. This exceeds the default 30-second timeout of many serverless environments (like Vercel/Next.js) and triggers rate limiting faster due to the prolonged connection duration.",
              "conclusion": "The performance issue is a critical bottleneck that will cause 'readFilesFromGitHub' to fail frequently on standard-sized production repositories.",
              "confidence": "high"
            },
            {
              "step": 3,
              "thought": "Identify the optimal concurrency strategy to resolve the bottleneck.",
              "analysis": "Simply wrapping the loop in 'Promise.all' without limits could trigger 429 (Too Many Requests) from GitHub if hundreds of files are fetched simultaneously. A semaphore or concurrency-limited pool (like 'p-limit') is required to process multiple requests in parallel (e.g., 5-10 at a time) to balance speed with API stability.",
              "conclusion": "Parallelization with a concurrency cap is the necessary fix to ensure both speed and reliability.",
              "confidence": "high"
            },
            {
              "step": 4,
              "thought": "Propose a structural code change based on the analysis.",
              "analysis": "Refactor the 'for' loop to map items to promises. Use 'p-limit' to wrap the fetch and recursive calls. Instead of 'files.push(...subFiles)', use 'Promise.all' to collect results from the limited execution pool.",
              "conclusion": "Implementation should transition from 'await inside loop' to 'Promise.all(itemsArray.map(item => limit(() => process(item))))'.",
              "confidence": "medium"
            }
          ],
          "finalDecision": "Based on my analysis, this issue requires refactoring the recursive traversal logic from a serial 'await-in-loop' pattern to a parallel execution pattern using 'Promise.all' combined with a concurrency limiter to prevent API rate-limit exhaustion while significantly reducing execution time.",
          "reasoningPath": "Identify sequential bottleneck  Calculate latency impact on timeouts  Determine need for capped concurrency  Propose 'p-limit' refactor  Final Decision"
        },
        "explainFix": {
          "issue": {
            "type": "performance",
            "severity": "medium",
            "file": "lib/services/repoReader.ts",
            "line": 105,
            "description": "Sequential recursive API calls. 'readDirectoryRecursive' awaits each subdirectory and file download sequentially. For large repositories, this leads to extremely long execution times and potential API timeouts.",
            "suggestion": "Implement concurrency limits using 'Promise.all' with a semaphore or a library like 'p-limit' to fetch multiple files/directories in parallel."
          },
          "whyDangerous": "The current implementation uses a 'Stop-and-Wait' approach for every network request. In the recursive loop, `await readDirectoryRecursive` and `await fetch(item.download_url)` block the entire execution thread until the individual HTTP request completes. For a repository with 100 files and 20 directories, the code performs at least 120 sequential round-trips to GitHub's servers. If each request takes 200ms, the process takes 24 seconds minimum, excluding processing time. This leads to: 1. **Serverless/API Timeouts:** Most cloud platforms (like Vercel or AWS Lambda) have execution limits (usually 10-30s). Large repositories will consistently trigger 504 Gateway Timeouts. 2. **Poor UX:** Users are forced to wait minutes for a task that should take seconds. 3. **Resource Starvation:** The connection stays open longer than necessary, consuming memory and execution slots in the runtime environment.",
          "howToFixManually": "1. Install a concurrency limiting library like `p-limit` (npm install p-limit) to avoid hitting GitHub's secondary rate limits or exhausting local sockets.\n2. Initialize a limit instance: `const limit = pLimit(10);` (allowing 10 concurrent requests).\n3. Refactor the `for...of` loop in `readDirectoryRecursive` to map items to an array of Promises.\n4. Use `Promise.all()` to execute these promises in parallel.\n\nExample implementation snippet:\n```typescript\nimport pLimit from 'p-limit';\nconst limit = pLimit(10);\n\nasync function readDirectoryRecursive(...) {\n  // ... fetch items ...\n  const tasks = itemsArray.map(item => limit(async () => {\n    if (item.type === 'dir') {\n      const subUrl = `.../${item.path}`;\n      return await readDirectoryRecursive(subUrl, owner, repo, item.path);\n    } else if (item.type === 'file' && isCodeFile(item.name)) {\n      const content = await fetchFileContent(item);\n      return [{ path: item.path, content, language: detect(item.name) }];\n    }\n    return [];\n  }));\n\n  const results = await Promise.all(tasks);\n  return results.flat();\n}\n```\n5. Apply the same logic to `countFilesRecursive` to speed up the initial counting phase.",
          "impact": "Fixing this will drastically improve performance (likely 5x-10x speedup for most repositories). There are no breaking changes to the function signatures. The main side effects are: 1. **Memory Usage:** Spawning many promises simultaneously increases transient memory consumption. 2. **API Rate Limits:** You will consume your GitHub API quota much faster; however, for the Contents API, this is usually acceptable as long as you use a personal access token.",
          "priority": "medium",
          "estimatedTime": "30 minutes",
          "difficulty": "medium"
        }
      },
      "app/api/sessions/route.ts-quality-low-Inefficient session cleanup. The code reads and pa": {
        "explainFix": {
          "issue": {
            "type": "quality",
            "severity": "low",
            "file": "app/api/sessions/route.ts",
            "line": 95,
            "description": "Inefficient session cleanup. The code reads and parses every single session file to find timestamps for cleanup. This O(n) operation runs on every POST request and will become slow as the number of sessions grows.",
            "suggestion": "Store session metadata in a single index file or database to avoid reading and parsing all files just for a cleanup check."
          },
          "whyDangerous": "While categorized as a 'quality' issue, this pattern creates a significant performance-based Denial of Service (DoS) risk. As the session count grows, the server spends increasing amounts of CPU and I/O time performing redundant work: reading every file from disk and parsing JSON content just to extract a single timestamp. On every POST request, this blocks the event loop and saturates Disk I/O. In a production environment with high concurrency, this will lead to API timeouts, high latency for all users, and potential server crashes due to resource exhaustion. It is a 'Time-of-Check to Time-of-Use' inefficiency where the cost of saving one session is proportional to the total history of sessions.",
          "howToFixManually": "There are three primary ways to fix this, ranging from quick optimizations to architectural improvements:\n\n1. **Use File Metadata (Fastest Fix):** Instead of reading and parsing file content, use `fs.stat` to get the file's modification time (`mtime`). This avoids expensive JSON parsing.\n2. **Timestamped Filenames (Best for File-based):** Save files using the format `${timestamp}_${id}.json`. This allows you to sort the list of files alphabetically using `fs.readdir` without opening a single file, reducing the operation from O(n) I/O reads to a simple O(n log n) string sort.\n3. **Database Migration:** For a professional production app, move session storage to a database (like SQLite or PostgreSQL). This allows you to run a single SQL command: `DELETE FROM sessions WHERE id NOT IN (SELECT id FROM sessions ORDER BY timestamp DESC LIMIT 50)`. \n\n**Example Implementation (Option 2):**\n```typescript\n// Change fileName to include timestamp\nconst fileName = `${Date.now()}_${session.id}.json`;\nconst files = await fs.readdir(SESSIONS_DIR);\nconst jsonFiles = files.filter(f => f.endsWith('.json')).sort(); // Lexicographical sort works because of timestamp prefix\nif (jsonFiles.length > 50) {\n  const toDelete = jsonFiles.slice(0, jsonFiles.length - 50);\n  for (const file of toDelete) {\n    await fs.unlink(path.join(SESSIONS_DIR, file));\n  }\n}\n```",
          "impact": "Fixing this will drastically reduce the latency of the POST `/api/sessions` endpoint. If you choose the 'Timestamped Filename' approach, you will need to update the GET method to handle the new filename format. There are no breaking changes for the API consumers (frontend), as the JSON response structure remains identical. Performance will remain constant regardless of the number of historical sessions processed.",
          "priority": "medium",
          "estimatedTime": "45 minutes",
          "difficulty": "medium"
        }
      },
      "lib/services/repoReader.ts-security-medium-GitHub API Rate Limiting. The fetch calls to GitHu": {
        "reasoningChain": {
          "issue": {
            "type": "security",
            "severity": "medium",
            "file": "lib/services/repoReader.ts",
            "line": 84,
            "description": "GitHub API Rate Limiting. The fetch calls to GitHub are unauthenticated. GitHub limits unauthenticated requests to 60 per hour per IP. Multiple users will quickly exhaust this quota, causing the app to fail.",
            "suggestion": "Implement GitHub OAuth or use a Personal Access Token (PAT) passed via environment variables in the request headers."
          },
          "steps": [
            {
              "step": 1,
              "thought": "I need to evaluate how the application interacts with the GitHub API and identify the current authentication state.",
              "analysis": "Inspecting 'readDirectoryRecursive' and 'countFilesRecursive' in 'lib/services/repoReader.ts', I observe that the 'fetch' calls to 'api.github.com' are made without any Authorization headers. By default, the GitHub REST API treats these as unauthenticated requests.",
              "conclusion": "The application is currently making unauthenticated requests, which are subject to GitHub's strict rate limit of 60 requests per hour per IP address.",
              "confidence": "high"
            },
            {
              "step": 2,
              "thought": "I should determine the impact of the recursive directory traversal on the rate limit quota.",
              "analysis": "The 'readDirectoryRecursive' function performs a new API call for every subdirectory encountered in a repository. For a standard project with dozens of folders, a single user could exhaust the 60-request hourly limit in one or two repository scans.",
              "conclusion": "The recursive architecture compounds the risk; as the number of users or the depth of the repositories increases, the application will experience frequent 403 Forbidden errors.",
              "confidence": "high"
            },
            {
              "step": 3,
              "thought": "I will examine the current error handling logic to see how the app reacts when the quota is actually hit.",
              "analysis": "The code currently checks for 'response.status === 403' and logs a warning stating 'Rate limit may be exceeded,' returning an empty array. In 'app/api/analyze/route.ts', the error is caught and returns a 429 status code if the error message contains 'quota'.",
              "conclusion": "While the app gracefully reports the failure, it does not prevent it. The user experience is broken because the core functionality (code analysis) becomes unavailable for an hour once the limit is reached.",
              "confidence": "medium"
            },
            {
              "step": 4,
              "thought": "I need to identify the most effective remediation strategy to increase the rate limit.",
              "analysis": "GitHub increases rate limits significantly for authenticated requests (up to 5,000 per hour). This can be achieved by providing a Personal Access Token (PAT) or using an OAuth App flow.",
              "conclusion": "The most immediate fix is to implement an environment variable (e.g., GITHUB_TOKEN) and inject it into the fetch headers. For a multi-tenant production app, implementing GitHub OAuth would be the more scalable long-term solution.",
              "confidence": "high"
            }
          ],
          "finalDecision": "This is a medium-severity security and availability issue. The fix requires updating the 'fetch' utility to include an 'Authorization' header using a token from process.env.GITHUB_TOKEN to raise the rate limit from 60 to 5,000 requests per hour.",
          "reasoningPath": "Identify unauthenticated calls  Analyze recursive overhead  Evaluate current error handling  Determine authentication requirements  Final Decision"
        }
      },
      "lib/services/codeAnalyzer.ts-bug-medium-Inconsistent Issue Mapping. The 'CodeIssue' interf": {
        "explainFix": {
          "issue": {
            "type": "bug",
            "severity": "medium",
            "file": "lib/services/codeAnalyzer.ts",
            "line": 102,
            "description": "Inconsistent Issue Mapping. The 'CodeIssue' interface defines 'type' as a union of 5 specific strings, but 'analyzeCodebase' relies on AI to return valid JSON. There is no runtime validation to ensure the AI actually returned one of those 5 types.",
            "suggestion": "Implement a schema validation layer (like Zod) to validate the AI response and map unexpected types to a 'quality' default."
          },
          "whyDangerous": "This issue represents a 'Type Pollution' or 'Data Integrity' vulnerability at the boundary between an untrusted external source (the AI model) and the internal application logic. While TypeScript provides compile-time safety, `JSON.parse()` returns an `any` type, which bypasses these checks at runtime. \n\nIf the AI returns a type outside the expected union (e.g., 'vulnerability' instead of 'security'), any code that relies on that typesuch as UI components using it as a key for icons (`Icons[issue.type]`), filtering logic, or database insertionwill likely crash or behave unpredictably. In a security context, if a 'security' issue is misclassified as an unknown type by the AI and your system fails to handle that unknown type, critical vulnerabilities might be hidden from the user or fail to trigger necessary alerts.",
          "howToFixManually": "1. Install a schema validation library like Zod: `npm install zod`.\n2. Define a schema that matches your `CodeIssue` interface.\n3. Use the `.catch()` or a transform method to handle invalid enum values.\n\nExample Implementation:\n```typescript\nimport { z } from 'zod';\n\nconst IssueSchema = z.object({\n  type: z.enum(['bug', 'security', 'performance', 'quality', 'error_handling'])\n    .catch('quality'), // Default to 'quality' if AI returns something else\n  severity: z.enum(['high', 'medium', 'low']).catch('low'),\n  file: z.string(),\n  line: z.number().optional(),\n  description: z.string(),\n  suggestion: z.string().optional(),\n});\n\nconst AnalysisSchema = z.object({\n  issues: z.array(IssueSchema),\n  structure: z.object({\n    mainFiles: z.array(z.string()),\n    dependencies: z.array(z.string()),\n    architecture: z.string(),\n  }),\n  summary: z.string(),\n});\n\n// Inside analyzeCodebase:\nconst rawData = JSON.parse(jsonMatch[0]);\nconst validatedData = AnalysisSchema.parse(rawData);\nreturn {\n  ...validatedData,\n  totalFiles: files.length,\n  // ... rest of mapping\n};\n```",
          "impact": "The fix will improve system resilience significantly. There are no negative performance implications as schema validation for a few dozen issues is computationally negligible. It ensures the UI remains stable and that data stored in the system strictly adheres to the defined types. No breaking changes are expected, as unexpected types are simply normalized to a valid default like 'quality'.",
          "priority": "medium",
          "estimatedTime": "30-45 minutes",
          "difficulty": "easy"
        }
      }
    },
    "businessImpactData": {
      "app/api/marathon/route.ts-bug-high-State persistence issue. The 'activeAgents' Map is": {
        "issueId": "app/api/marathon/route.ts-bug-high",
        "impactScore": 75,
        "priority": "high",
        "explanation": "This high severity bug issue could impact user experience and system reliability.",
        "estimatedCost": {},
        "businessMetrics": {}
      },
      "app/api/sessions/[id]/route.ts-security-high-Path Traversal vulnerability. The 'id' parameter f": {
        "estimatedCost": {
          "revenue": "High risk of GDPR/CCPA fines (up to 4% of global turnover) and loss of high-value enterprise contracts due to failed security audits.",
          "users": "Potential for 100% churn of affected users if session data is leaked or deleted; high risk of total service abandonment following a public breach.",
          "time": "40-80+ hours of emergency engineering response, forensic auditing, and legal/compliance review.",
          "reputation": "Severe damage; brand perceived as insecure, leading to long-term difficulty in acquiring B2B customers."
        },
        "businessMetrics": {
          "conversion": "N/A - Primarily a backend security risk, though trust-based conversion may drop after public disclosure.",
          "seo": "Risk of domain blacklisting by search engines if the vulnerability is used to host or distribute malicious content via manipulated files.",
          "security": "Critical compromise of Confidentiality (unauthorized read) and Availability (unauthorized deletion) of server-side data.",
          "performance": "Potential for total service outage if critical configuration JSON files are deleted by an attacker."
        },
        "impactScore": 92,
        "priority": "critical",
        "explanation": "This vulnerability allows unauthorized actors to delete system-critical files or steal sensitive session data, directly violating data protection laws. The ability to delete JSON files can lead to catastrophic data loss and prolonged service downtime, making it a top-tier business risk.",
        "realWorldExample": "An attacker uses a DELETE request to `/api/sessions/..%2f..%2fconfig%2fsettings.json`, wiping the application's configuration. This takes the entire platform offline for hours. Simultaneously, they use GET requests to download all session files, stealing active login tokens for thousands of users to perform account takeovers.",
        "issueId": "app/api/sessions/[id]/route.ts-security-high"
      },
      "app/api/sessions/route.ts-quality-low-Inefficient session cleanup. The code reads and pa": {
        "estimatedCost": {
          "revenue": "Potential 5-10% loss during high-traffic events due to transaction timeouts.",
          "users": "Increased bounce rate on login/signup pages as latency grows with user base.",
          "time": "High ops cost for troubleshooting 'random' server slowdowns and I/O bottlenecks.",
          "reputation": "Risk of being perceived as an unstable or slow platform during growth phases."
        },
        "businessMetrics": {
          "conversion": "Degradation of 'Sign Up' and 'Login' conversion rates as response times increase.",
          "seo": "Negative impact on Search Engine rankings due to poor Core Web Vitals (Interaction to Next Paint).",
          "security": "High vulnerability to Denial of Service (DoS) attacks via session flooding.",
          "performance": "Linear increase in API latency (O(n)) relative to the total number of active/expired sessions."
        },
        "impactScore": 55,
        "priority": "medium",
        "explanation": "This is a 'ticking time bomb' scalability issue. While performance is fine with few users, the O(n) cleanup on every POST request means the app will eventually crawl to a halt or crash as the business grows, exactly when reliability matters most.",
        "realWorldExample": "During a successful marketing campaign, the session count spikes from 1,000 to 50,000. Every new customer trying to log in triggers a disk-heavy scan of all 50,000 files, causing the server to exceed its I/O limits and time out, leading to a total failure of the campaign's conversion funnel.",
        "issueId": "app/api/sessions/route.ts-quality-low"
      },
      "lib/services/codeAnalyzer.ts-bug-medium-Inconsistent Issue Mapping. The 'CodeIssue' interf": {
        "issueId": "lib/services/codeAnalyzer.ts-bug-medium",
        "impactScore": 50,
        "priority": "medium",
        "explanation": "This medium severity bug issue could impact user experience and system reliability.",
        "estimatedCost": {},
        "businessMetrics": {}
      },
      "lib/services/repoReader.ts-performance-medium-Sequential recursive API calls. 'readDirectoryRecu": {
        "issueId": "lib/services/repoReader.ts-performance-medium",
        "impactScore": 50,
        "priority": "medium",
        "explanation": "This medium severity performance issue could impact user experience and system reliability.",
        "estimatedCost": {},
        "businessMetrics": {}
      },
      "lib/services/repoReader.ts-security-medium-GitHub API Rate Limiting. The fetch calls to GitHu": {
        "issueId": "lib/services/repoReader.ts-security-medium",
        "impactScore": 50,
        "priority": "medium",
        "explanation": "This medium severity security issue could impact user experience and system reliability.",
        "estimatedCost": {},
        "businessMetrics": {}
      },
      "lib/services/autoFix.ts-error_handling-medium-Fragile JSON parsing. The service uses a RegExp to": {
        "estimatedCost": {
          "revenue": "Potential loss of subscription or feature usage revenue due to user frustration and churn.",
          "users": "Significant increase in user frustration, leading to higher churn rates, reduced engagement with the `autoFix` feature, and negative sentiment.",
          "time": "Increased customer support tickets related to autoFix failures (estimated X hours/week), developer time spent debugging and hotfixing (estimated Y hours/week), and wasted user time on retries or manual workarounds.",
          "reputation": "Severe damage to product reputation for reliability and effectiveness, especially for an AI-powered feature where correct output parsing is fundamental."
        },
        "businessMetrics": {
          "conversion": "Reduced conversion rates from trial users to paid subscriptions if the autoFix feature is a key differentiator or part of the conversion funnel.",
          "seo": "N/A",
          "security": "N/A (The primary risk is functional failure, not direct security vulnerability, though fragile parsing can sometimes obscure deeper issues.)",
          "performance": "Increased latency for autoFix operations as parsing fails and retries occur, potentially leading to higher server load from failed attempts."
        },
        "impactScore": 85,
        "priority": "critical",
        "explanation": "This issue directly breaks a core `autoFix` functionality by failing to correctly parse AI responses that are common in real-world scenarios. This leads to severe user frustration, increased churn, significant reputational damage for the AI product, and potential revenue loss as users abandon an unreliable feature.",
        "realWorldExample": "A developer uses the `autoFix` feature in their IDE to resolve a complex bug. The AI assistant generates a correct JSON output containing the fix, but wraps it within standard Markdown code fences (e.g., ` ```json { ... } ``` `) or includes a brief conversational intro before the JSON. Due to the fragile RegExp, the service fails to correctly extract and parse the JSON, resulting in a 'Fix Failed' error message. The developer, unable to utilize the core feature, becomes frustrated, loses trust in the AI's capability, and may seek alternative tools.",
        "issueId": "lib/services/autoFix.ts-error_handling-medium"
      }
    }
  },
  "config": {
    "testTypes": [
      "unit",
      "integration",
      "security"
    ],
    "duration": "one-time",
    "autoFix": true
  }
}